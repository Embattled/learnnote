- [1. C 语言](#1-c-语言)
  - [1.1. C语言的版本](#11-c语言的版本)
- [2. C 保留字](#2-c-保留字)
  - [2.1. C语言的 const](#21-c语言的-const)
- [3. C语言指针](#3-c语言指针)
    - [3.0.1. 指针的定义](#301-指针的定义)
    - [3.0.2. 数组指针 数组名](#302-数组指针-数组名)
    - [3.0.3. 数组和指针的可交换性 下标 []](#303-数组和指针的可交换性-下标-)
    - [3.0.4. C语言字符串](#304-c语言字符串)
    - [3.0.5. 函数中的指针](#305-函数中的指针)
    - [3.0.6. NULL 指针](#306-null-指针)
    - [3.0.7. void 指针](#307-void-指针)
    - [3.0.8. 函数指针](#308-函数指针)
- [4. 预处理命令](#4-预处理命令)
  - [4.1. include](#41-include)
  - [4.2. define 宏定义](#42-define-宏定义)
    - [4.2.1. 带参数的宏定义](#421-带参数的宏定义)
    - [4.2.2. 特殊宏定义](#422-特殊宏定义)
  - [4.3. 条件宏](#43-条件宏)
    - [4.3.1. if](#431-if)
    - [4.3.2. ifdef](#432-ifdef)
  - [4.4. error 报错停止](#44-error-报错停止)
  - [4.5. 预定义宏](#45-预定义宏)
    - [4.5.1. 平台](#451-平台)
    - [4.5.2. 编译模式](#452-编译模式)
- [5. 多文件编程](#5-多文件编程)
  - [5.1. 从 extern 开始](#51-从-extern-开始)
  - [5.2. 防止重复包含头文件](#52-防止重复包含头文件)
  - [5.3. 命名空间](#53-命名空间)
  - [5.4. const 在多文件编程中](#54-const-在多文件编程中)
  - [5.5. 头文件应该写什么](#55-头文件应该写什么)
- [6. C 语言和内存](#6-c-语言和内存)
  - [6.1. 操作系统基础](#61-操作系统基础)
    - [6.1.1. 虚拟内存](#611-虚拟内存)
    - [6.1.2. 编译模式](#612-编译模式)
    - [6.1.3. 地址对齐](#613-地址对齐)
    - [6.1.4. 内存分页](#614-内存分页)
    - [6.1.5. MMU](#615-mmu)
  - [6.2. C语言的内存布局](#62-c语言的内存布局)
    - [6.2.1. 内核空间](#621-内核空间)
    - [6.2.2. Linux 的内存模型](#622-linux-的内存模型)
    - [6.2.3. Windows 的内存模型](#623-windows-的内存模型)
  - [6.3. 进程与内存](#63-进程与内存)
    - [内核模式与用户模式](#内核模式与用户模式)
    - [栈与进程](#栈与进程)
- [7. dlfcn.h  显示调用动态链接库](#7-dlfcnh--显示调用动态链接库)

# 1. C 语言

## 1.1. C语言的版本

**前身**:
* 1969 : B语言出现, 加入了 `++ --` 运算符, 无数据类型语言
* 1971 : NB (New B) 语言出现, 出现了 `int char arrays pointers`等类型
* 1972 : NB 重命名为 C, 加入了结构体, 预处理命令, 逻辑 `&& ||`, 还有便携 IO
* 1973 : Unix 重写了 C, 加入了 `unsigned long unions` 增加了类型的安全性
* 1978 : C 语言正式诞生

**标准C语言**
* 1983 : ANSI 建立了 `X3J11` 委员会用于制定 C 语言标准
* 1988 : C 语言 2nd 版本发布
* 1989 : ANSI 发布了第一个 C 语言标准 `C89 / ANSIC`, 
* 1990 : ANSI 将 C标准提交到 ISO, 被称为 `C90`
* 1995 : `C95` 加入了宽字符的支持 `wctype`
* 1999 : `C99` 加入 `bool longlong` 等新特性
* 2011 : `C11` 加入了线程意识的内存管理等新特性
* 2018 : `C17` 新特性


**总结**
1. C89/C90
   * 第一个C语言标准通常被称为 `ANSI C`。又由于这个版本是 89 年完成制定的, 因此也被称为 C89。
   * 后来 ANSI 把这个标准提交到 ISO（国际化标准组织）, 1990 年被 ISO 采纳为国际标准, 称为 `ISO C`。又因为这个版本是1990年发布的, 因此也被称为 C90。
   * 因为 ANSI 与 ISO 的C标准内容基本相同, 所以对于C标准, 可以称为 ANSI C, 也可以说是 ISO C, 或者 ANSI / ISO C。  
   * 看到 ANSI C, ISO C, C89, C90, 要知道这些标准的内容都是一样的
2. C99
   * 增加了新的关键字, 编写了新的库, 取消了原有的限制, 并于 1999 年形成新的标准——ISO/IEC 9899:1999 标准, 通常被成为 C99。
   * 当 GCC 和其它一些商业编译器支持 C99 的大部分特性的時候, 微软和 Borland 却似乎对此不感兴趣, 或者说没有足够的资源和动力来改进编译器, 最终导致不同的编译器在部分语法上存在差异。
3. C11
   * 国际标准化组织（ISO）和国际电工委员会（IEC） 旗下的C语言标准委员会于 2011 年底正式发布  
   * 支持此标准的主流C语言编译器有 GCC, LLVM/Clang, Intel C++ Compile 等。  


C11 标准主要增加了以下内容：
    增加了安全函数, 例如 `gets_s()`, `fopen_s()` 等；
    增加了 `<threads.h>` 头文件以支持多线程；
    增加了 `<uchar.h>` 头文件以支持 Unicode 字符集；

* 现有的教程（包括书籍, 视频, 大学课程等）大都是针对 C89 编写的, 这是C语言的核心, 后来的 C99, C11 新增的特性并不多, 只是在“打补丁”。
* 每次的更新, C 语言都会融合一些 C++的特性作为自己的内容, C和C++相互依存同时还互相学习




# 2. C 保留字

## 2.1. C语言的 const

常量一旦被创建后其值就不能再改变, 所以常量必须在定义的同时赋值（初始化）, 后面的任何赋值行为都将引发错误。
* const 也可以和指针变量一起使用, 这样可以限制指针变量本身, 也可以限制指针指向的数据
* const 在*号后面的 代表指针本身为常量
* 为了保证 const 的完备, 编译器一般不会允许 const 向非 const 变量赋值, 但是反之可以  

```c
const int MaxNum = 100; 

// const 和 type 都是用来修饰变量的, 它们的位置可以互换
// 建议将常量名的首字母大写, 以提醒程序员这是个常量
const type Name = value;

// 常量指针的三种形式
const int *p1;    // 常用这种 , 指针所指向的数据是只读的
int const *p2;    // 这两种也就是 const 和 type 可以互换的类型 , 指针所指向的数据是只读的
int * const p3;   // 指针是只读的, 也就是 p3 本身的值不能被修改；

// 还有一种指针本身和它指向的数据都有可能是只读的
const int * const p4;
int const * const p5; // 交换后的写法

```

在C语言中, 单独定义 const 变量没有明显的优势, 完全可以使用#define命令代替。  
因此: const 通常用在函数形参中, 如果形参是一个指针, 为了防止在函数内部修改指针指向的数据, 就可以用 const 来限制。  



# 3. C语言指针

`*` 在不同的场景下有不同的作用：
    1. 表示乘法, 例如 `int a = 3, b = 5, c;  c = a * b;` 这是最容易理解的。
    2. `*`可以用在指针变量的定义中, 表明这是一个指针变量, 以和普通变量区分开；
    3. 使用指针变量时在前面加`*`表示获取指针指向的数据, 或者说表示的是指针指向的数据本身

和指针相关的运算符优先级从高到低依次是
1. 定义中被括号( )括起来的那部分。
2. 后缀操作符：括号( )表示这是一个函数, 方括号[ ]表示这是一个数组。
3. 前缀操作符：星号`*`表示 “指向xxx的指针”。


### 3.0.1. 指针的定义
```c
// C语言的指针定义符号 * 是后结合的
//a, b, c 的类型都是 int*
int *a, *b, *c;  

// 只有 a 是指针变量, b, c 都是类型为 int 的普通变量
int *a, b, c;
```

### 3.0.2. 数组指针 数组名

* `数组名` 可以 `认为` 是一个指针, 它指向数组的第 0 个元素, 数组名和数组首地址并不总是等价
* 如果 p 是指向数组 arr 的指针, 那么也可以使用 `p[i]` 来访问数组元素, 它等价于 `arr[i]`。 
* 数组名是常量, 它的值不能改变, 而数组指针是变量（除非特别指明它是常量）, 它的值可以任意改变

```cpp
int arr[] = { 99, 15, 100, 888, 252 };

// 可以定义一个指向数组的指针
int *p = arr;
// p 指向数组中的第二个元素
int *p = &arr[2];  //也可以写作 int *p = arr + 2;


// 指针数组   二维数组指针
// [ ]的优先级高于*
int *(p1[5]);  // 指针的数组,  可以去掉括号直接写作 int *p1[5]; 一个有5个元素的数组, 元素类型是 int *
int (*p2)[5];  // 二位数组的指针, 不能去掉括号, 一个指针指向了 int[6] 类型, 通过p2+1 代表二位数组下降一行
```

数组名和指针的区别:
1. 求数组的长度, 只能使用数组名, 不能使用数组指针
2. 用操作符 sizeof 对数组名可以得到整个数组所占用的字节, 而对指针使用只会得到指针占用的字节

与普通变量名相比, 数组名既有一般性也有特殊性：
1. 一般性表现在数组名也用来指代特定的内存块, 也有类型和长度
2. 特殊性表现在数组名有时候会转换为一个指针, 而不是它所指代的数据本身的值。


### 3.0.3. 数组和指针的可交换性 下标 [] 

数组是有具体类型的, 定义一个数组 `a[6]`, 它的类型是`int [6]` 表示这是一个拥有 6 个 int 数据的集合  

C语言标准规定下列情况时,  数组类型被当作数组类型看待  
1. 当数组名作为数组定义的标识符（也就是定义或声明数组时）
2. sizeof 或 & 的操作数时

除此之外的其他的**所有**表达式中, 数组名会被转换为指向第 0 个元素的指针  
这代表以下的函数定义是完全等价的
```cpp
void func(int *parr){ ...... }
void func(int arr[]){ ...... }
void func(int arr[5]){ ...... }
// 用 sizeof(arr) 求得的是指针变量的长度, 而不是数组长度
// 要想在函数内部获得数组长度必须额外增加一个参数
```

C语言标准还规定, 数组下标`[]` 与指针的偏移量等价  
因此取下标操作符`[]`是建立在指针的基础上的一系列操作的集合:
1. 使一个指针和一个整数相加, 产生出一个新的指针
2. 然后从这个新指针（新地址）上取得数据, 即使用 `*` 运算符
对数组的引用 `a[i]` 在编译时总是被编译器改写成`*(a+i)`的形式, C语言标准也要求编译器**必须**具备这种行为。  

使用下标时, 编译器会自动把下标的步长调整到数组元素的大小:  
数组 a 中每个元素都是 int 类型, 长度为 4 个字节, 那么 `a[i+1]` 和 `a[i]` 在内存中的距离是 4（而不是 1）  


### 3.0.4. C语言字符串

C语言中没有特定的字符串类型, 我们通常是将字符串放在一个字符数组中

```cpp

char str[] = "c.biancheng.net";

// 除了字符数组, C语言还支持另外一种表示字符串的方法, 就是直接使用一个指针指向字符串
char *str = "c.biancheng.net";

// 或者
char *str;
str = "c.biancheng.net";

// 指针指向可以更改, 但是不能更改字符串数据
char *str = "Hello World!";
str = "I love C!";  //正确
str[3] = 'P';  //错误
```
两种字符串类型的区别:
1. 在内存中的存储区域不一样, 字符数组存储在全局数据区或栈区, 指针形式的字符串存储在常量区
2. 全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限
3. 常量区的字符串（也包括其他数据）只有读取权限, 没有写入权限.一旦被定义后就只能读取不能修改, 任何对它的赋值都是错误的


### 3.0.5. 函数中的指针

函数参数中的数组:
1. C语言没有从语法上支持数据集合的直接赋值
2. 在参数中书写 `int intArr[6]` 还是 `int intArr[]` 都不会创建一个数组出来, 编译器也不会为它们分配内存, 实际的数组是不存在的, 它们最终还是会转换为int *intArr这样的指针
   

函数返回值中的指针
* 函数运行结束后会销毁在它内部定义的所有局部数据, 包括局部变量, 局部数组和形式参数
* 函数返回的指针请尽量不要指向这些数据

### 3.0.6. NULL 指针

* 一个指针变量可以指向计算机中的任何一块内存, 不管该内存有没有被分配, 也不管该内存有没有使用权限, 只要把地址给它, 它就可以指向
* C语言没有一种机制来保证指向的内存的正确性, 程序员必须自己提高警惕


1. NULL 表示空指针, 是一个在 `C许多头文件中` 都定义了的宏定义, 可以在代码中直接使用
2. NUL 表示字符串的结束标志 '\0', 它是ASCII码表中的第 0 个字符。NUL 没有在C语言中定义, 仅仅是对 '\0' 的称呼, 不能在代码中直接使用


NULL 在C/C++中的定义
```cpp
// c

// 1. an integer constant expression with the value ​0​
// 2. an integer constant expression with the value 0 cast to the type void* 
// 3. A null pointer constant may be converted to any pointer type; such conversion results in the null pointer value of that type. 

// C++ compatible:
#define NULL 0

// C++ incompatible:
#define NULL (10*2 - 20)
#define NULL ((void*)0)  // 这一条是最二义性的

// -------c++-----
// (since C++11)
// 1. an integer literal with value zero
// 2. or a prvalue of type std::nullptr_t
#define NULL 0

//since C++11
#define NULL nullptr
```
### 3.0.7. void 指针

C语言的 NULL 定义为 `((void *)0)` 这也只存在于C语言

* `void` 用在函数定义中可以表示函数没有返回值或者没有形式参数
* `void *`, 表示指针指向的数据的类型是未知的。
    1. `void *` 表示一个有效指针, 它确实指向实实在在的数据, 它不是空指针的意思, 只是数据的类型尚未确定
    2. C语言动态内存分配函数 `malloc()` 的返回值就是void *类型, 因此C语言的 `malloc()` 在使用时要进行强制类型转换


### 3.0.8. 函数指针

函数指针的定义形式为:  
`returnType (*pointerName)(param list);`  
参数列表中可以同时给出参数的类型和名称, 也可以只给出参数的类型, 省略参数的名称  


第一个括号不能省略, 如果写作
`returnType *pointerName(param list);`  
就成了函数原型, 它表明函数的返回值类型为returnType *


定义`pmax` 是一个函数指针, 在前面加 * 就表示对它指向的函数进行调用。  
由于( )的优先级高于*,  `(*pmax)()` 两个括号不能省略    

# 4. 预处理命令

在编译之前对源文件进行简单加工的过程, 就称为预处理  

以`#`号开头的命令称为预处理命令  

1. 预处理 输出 `.i`
2. 编译 输出 `.o`
3. 连接 输出可执行文件

| 指令     | 说明                                                      |
| -------- | --------------------------------------------------------- |
| #        | 空指令, 无任何效果                                        |
| #include | 包含一个源代码文件                                        |
| #define  | 定义宏                                                    |
| #undef   | 取消已定义的宏                                            |
| #if      | 如果给定条件为真, 则编译下面代码                          |
| #ifdef   | 如果宏已经定义, 则编译下面代码                            |
| #ifndef  | 如果宏没有定义, 则编译下面代码                            |
| #elif    | 如果前面的#if给定条件不为真, 当前条件为真, 则编译下面代码 |
| #endif   | 结束一个#if……#else条件编译块                              |


## 4.1. include

`#include` 的处理过程很简单, 就是将头文件的内容插入到该命令所在的位置, 从而把头文件和当前源文件连接成一个源文件, 这与复制粘贴的效果相同。

使用尖括号< >和双引号" "的区别在于头文件的搜索路径不同：

    使用尖括号< >, 编译器会到系统路径下查找头文件；
    而使用双引号" ", 编译器首先在当前目录下查找头文件, 如果没有找到, 再到系统路径下查找。

也就是说, 使用双引号比使用尖括号多了一个查找路径, 它的功能更为强大。

## 4.2. define 宏定义

`宏定义`, 就是用一个标识符来表示一个字符串, 如果在后面的代码中出现了该标识符, 那么就全部替换成指定的字符串  (**简单粗暴的替换**)  

宏定义的一般形式为:  
`#define  宏名  字符串`  

注意点:  
1. 预处理程序对宏定义不作任何检查, 如有错误, 只能在编译已被宏展开后的源程序时发现
2. 宏定义不是说明或语句, 在行末不必加分号, 如加上分号则连分号也一起替换
3. 宏定义必须写在函数之外, 其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用`#undef`  
4. 对字符串不进行宏替换的话可以使用 双引号: `""`
5. 宏定义允许嵌套
6. 习惯上宏名用大写字母表示, 以便于与变量区别
7. 可用宏定义表示数据类型, 使书写方便 `#define UINT unsigned int`

### 4.2.1. 带参数的宏定义

`#define 宏名(形参列表) 字符串`  
* 宏名和形参列表之间不能有空格出现  
* 带参宏定义中, 不会为形式参数分配内存, 因此不必指明数据类型
* 字符串内的形参通常要用括号括起来以避免出错
  * 不仅要在参数两侧加括号, 还应该在整个字符串外加括号

```c
#define MAX(a,b) (a>b) ? a : b

// 错误
#define SQ(y) y*y 

// 错误
#define SQ(y) (y)*(y)

// 正确
#define SQ(y) ((y)*(y))
```
### 4.2.2. 特殊宏定义

在宏定义中的`#`: 用来将宏参数转换为字符串 也就是在带参数宏中的宏参数的开头和末尾添加引号  

```c
#define STR(s) #s

printf("%s", STR(c.biancheng.net));
// 等同于
printf("%s", "c.biancheng.net");

```

`##` 称为连接符, 用来将宏参数或其他的串连接起来  

```c
#define CON1(a, b) a##e##b

#define CON2(a, b) a##b##00

printf("%f\n", CON1(8.5, 2));
printf("%d\n", CON2(12, 34));

// 等同于
printf("%f\n", 8.5e2);
printf("%d\n", 123400);
```

## 4.3. 条件宏

条件编译是预处理程序的功能, 不是编译器的功能。  

### 4.3.1. if

* `#if`     命令要求判断条件为“整型常量表达式”, 也就是说, 表达式中不能包含变量, 而且结果必须是整数
* `if`      的表达式没有限制, 只要符合语法就行
```c
#if 整型常量表达式1
    程序段1

#elif 整型常量表达式2
    程序段2

#elif 整型常量表达式3
    程序段3

#else
    程序段4

#endif

```

### 4.3.2. ifdef

* #ifdef:   如果当前的宏已被定义过, 则对“程序段1”进行编译, 否则对“程序段2”进行编译。  
* #ifndef:  如果当前的宏未被定义, 则对“程序段1”进行编译, 否则对“程序段2”进行编译, 这与 #ifdef 的功能正好相反。

```cpp
#ifdef  宏名
    程序段1
#else
    程序段2
#endif
```

## 4.4. error 报错停止

`#error` 指令用于在编译期间产生错误信息 **并阻止程序的编译** , 其形式如下：  
`#error error_message`   

注意报错信息不需要加引号" "  

```c
#ifdef WIN32
#error This programme cannot compile at Windows Platform
#endif

#ifndef __cplusplus
#error 当前程序必须以C++方式编译
#endif

```
## 4.5. 预定义宏

预定义宏就是已经预先定义好的宏, 我们可以直接使用, 无需再重新定义  

| 宏名          | 功能                                            |
| ------------- | ----------------------------------------------- |
| `__LINE__`    | 表示当前源代码的行号；                          |
| `__FILE__`    | 表示当前源文件的名称；                          |
| `__DATE__`    | 表示当前的编译日期；                            |
| `__TIME__`    | 表示当前的编译时间；                            |
| `__STDC__`    | 当要求程序严格遵循ANSI C标准时该标识被赋值为1； |
| `__cplusplus` | 当编写C++程序时该标识符被定义。                 |

```c

printf("Date : %s\n", __DATE__);
// Date : Mar  6 2016
printf("Time : %s\n", __TIME__);
// Time : 11:47:15
printf("File : %s\n", __FILE__);
// File : main.c
// File : C:\Users\mozhiyan\Desktop\demo.c
printf("Line : %d\n", __LINE__);
// Line : 8

```
### 4.5.1. 平台

* Windows 有专有的宏    `_WIN32`
* Linux 有专有的宏      `__linux__`

```c
//不同的平台下引入不同的头文件
#if _WIN32  //识别windows平台
#include <windows.h>

#elif __linux__  //识别linux平台
#include <unistd.h>

#endif
```
### 4.5.2. 编译模式

VS/VC 有两种编译模式, Debug 和 Release  会定义对应的宏  
* `_DEBUG`

```c
#ifdef _DEBUG
    printf("正在使用 Debug 模式编译程序...\n");
#else
    printf("正在使用 Release 模式编译程序...\n");
#endif
```

# 5. 多文件编程

一个完整的 C++ 项目常常是由多个代码文件组成的, 根据后缀名的不同, 大致可以将它们分为如下 2 类：
* .h 文件：又称“头文件”, 用于存放常量, 函数的声明部分, 类的声明部分；
* .cpp 文件：又称“源文件”, 用于存放变量, 函数的定义部分, 类的实现部分。
注意, 引入编译器自带的头文件（包括标准头文件）用尖括号, 例如 `<iostream>`；引入自定义的头文件用 "" 双引号, 例如 `"student.h"`。 


实际上, 除了后缀不一样便于区分和管理外, 其他的几乎相同, 在 .cpp 中编写的代码同样也可以写在 .h 中。  
之所以将 .cpp 文件和 .h 文件在项目中承担的角色进行区别, 不是 C++ 语法的规定, 而是约定成俗的规范.  

1. 虽然类内部的成员函数可以在声明的同时进行定义（自动成为内联函数）, 但原则上不推荐这样使用。
   也就是说, 即便定义成员函数的代码很少, 其定义也应该放在适当的 .cpp 文件中。
2. 对于一些系统提供的库, 出于版权和保密的考虑, 大多是已经编译好的二进制文件, 其中可能仅包含 .h 文件, 而没有 .cpp 文件。

## 5.1. 从 extern 开始

1. 在实际开发中, 经常会在函数或变量定义之前就使用它们, 这个时候就需要提前声明。
2. 所谓声明（Declaration）, 就是告诉编译器我要使用这个变量或函数, 你现在没有找到它的定义不要紧, 请不要报错, 稍后我会把定义补上。

对于函数来说: 函数的定义有函数体, 函数的声明没有函数体, 编译器很容易区分定义和声明, 所以对于函数声明来说, 有没有 extern 都是一样的。  
对于变量来说: 编译器只能根据 extern 来区分, 有 extern 才是声明, 没有 extern 就是定义。  

变量的声明只有一种形式, 就是使用 extern 关键字：
```cpp
// 变量的声明
extern datatype name;
// 声明的同时初始化 但是没有实际意义
extern datatype name = value;
```
extern 是“外部”的意思, 很多教材讲到, extern 用来声明一个外部（其他文件中）的变量或函数, 也就是说, 变量或函数的定义在`其他文件`中。    
但是除了定义在外部, 定义在当前文件中也是正确的。  
因此本质上 extern 是用来声明的, 不管具体的定义是在当前文件内部还是外部, 都是正确的。  

## 5.2. 防止重复包含头文件 

1. 头文件包含命令 #include 的效果与直接复制粘贴头文件内容的效果是一样的, 预处理器实际上也是这样做的, 
   它会读取头文件的内容, 然后输出到 #include 命令所在的位置。  
2. 头文件包含是一个递归（循环）的过程, 如果被包含的头文件中还包含了其他的头文件, 预处理器会继续将它们也包含进来；
   这个过程会一直持续下去, 直到不再包含任何头文件, 这与递归的过程颇为相似。

C++ 多文件编程中, 处理多次 `#include` 导致重复引入”问题的方式有 3 种
1. 使用宏定义避免重复引入
   * #ifndef 是通过定义独一无二的宏来避免重复引入的, 这意味着每次引入头文件都要进行识别, 所以效率不高。
   * 但考虑到 C 和 C++ 都支持宏定义, 所以项目中使用 `#ifndef` 规避可能出现的“头文件重复引入”问题, 不会影响项目的可移植性。
2. 使用`#pragma once`避免重复引入
   * 一些较老版本的编译器不支持该指令
   * 但是实际中在 C/C++ , #pragma once 是一个非标准但却逐渐被很多编译器支持的指令。
3. 使用_Pragma操作符 (C99)
   * 可以看做是 `#pragma` 的增强版, 不仅可以实现 `#pragma` 所有的功能, 更重要的是, `_Pragma` 还能和宏搭配使用。
   * _Pragma 和 #pragma 有很多其他用法
4. 实际使用中
   * 强烈推荐读者选用第1种解决方案, 即采用 `#ifndef / #define / #endif`组合解决头文件被重复引入。
   * 同时考虑到编译效率和可移植性, #pragma once 和 #ifndef 经常被结合使用
   * 当编译器可以识别 #pragma once 时, 则整个文件仅被编译一次；反之, 即便编译器不识别 #pragma once 指令, 此时仍有 #ifndef 在发挥作用。


```cpp
// 宏保护的具体写法

// 这里 文件名为 xyz.h
#ifndef _XYZ_H
#define _XYZ_H
/* 具体的头文件内容 */
#endif
// 这样只要有任意一个文件包含了 `#include "xyz.h"` 则宏就会被定义, 之后的文件再包含也不会造成重复定义


// **pragma 的用法**

// 注意 #pragma once 是针对整个文件的
#pragma once
class Student {
  //......
};

// 或者
_Pragma("once")
class Student {
  //......
};

// 组合使用也可以
#pragma once
#ifndef _STUDENT_H
#define _STUDENT_H
class Student {
   //......
};
#endif
```

## 5.3. 命名空间

1. 不同头文件中也可以使用名称相同的命名空间, 但前提是位于该命名空间中的成员必须保证互不相同。
2. 当类的声明位于指定的命名空间中时, 如果要在类的外部实现其成员方法, 需同时注明**所在命名空间名和类名**  `Li::Student::display() `
3. C++ 中 `display()` 和 `display(int n)` 并不会造成重定义, 它们互为重载函数

## 5.4. const 在多文件编程中

1. 用 const 修饰的变量必须在定义的同时进行初始化操作
2. const 关键字除了表明其修饰的变量为常量外  还将所修饰变量的 `可见范围限制为当前文件`  
   因此除非 const 常量的定义和 main 主函数位于同一个 `.cpp` 文件, 否则该 const 常量只能在其所在的 `.cpp` 文件中使用

三种在多文件编程中使用其他文件中的 const 常量的方法  
第一种方式更简单, 更常用  习惯什么的都别在意  

1. 将const常量定义在.h头文件中  最常用也最简单的方法

此方式违背了“声明位于 .h 文件, 定义（实现）位于 .cpp 文件”的规律.
但是实际上还有别的习惯也是违背这个规律的 分别是 类的定义和内联函数的定义, 通常情况下它们也都定义在 .h 文件中。
```cpp
//demo.h
#ifndef _DEMO_H
#define _DEMO_H
const int num = 10;
#endif

```
2. 借助extern先声明再定义const常量

借助 extern 关键字 , 就可以遵守 “声明位于 .h 文件, 定义（实现）位于 .cpp 文件”的规律  
定义在 h 头文件中的 extern const 可以将 常量的作用范围恢复到整个文件  

```cpp
//demo.h
#ifndef _DEMO_H
#define _DEMO_H
extern const int num;  //声明 const 常量
#endif

//demo.cpp
#include "demo.h"   //一定要引入该头文件
const int num =10; // 定义
```

3. 借助extern直接定义const常量

在第2种的基础上进一步优化,直接省略掉头文件的建立, 但是这不符合编程结构习惯  
```cpp
//demo.cpp
extern const int num =10;

//main.cpp
extern const int num;
int main() {
  std::cout << num << std::endl;
  return 0;
}
```
## 5.5. 头文件应该写什么

因为声明语句是可以重复的
1. 区分普通函数和变量的声明和定义
2. 头文件中可以定义 const 对象和 static 对象
3. 头文件中可以定义内联函数 （用 inline 修饰的函数）
4. 头文件中可以定义类

```cpp
// 变量和函数的声明
extern int a;
void f();

// 定义 要区分好
int a;
void f() {}

// 成员变量是要等到具体的对象被创建时才会被定义（分配空间）
// 因此成员变量放在头文件中, 而把成员函数的实现代码放在一个 .cpp 文件中
class a{
    int a;
}
```

# 6. C 语言和内存

CPU的寄存器:
* EIP (Extern Instruction Pointer) : 下一条指令的地址
* CR3 : 当前进程 `页目录` 的物理地址
* EBP : 用来指向栈底
* ESP : 用来指向栈顶

## 6.1. 操作系统基础
CPU 一个时钟内 能处理的数据大小 = 寄存器的位数 = 数据总线的宽度

### 6.1.1. 虚拟内存

* 对于程序中的全局变量, 它们的内存地址在链接时就已经被确定了, 无论程序在何时运行, 都是同样的地址
* 即 程序中看到的地址都是虚拟地址  
* 操作系统会寻找空闲的一段物理地址, 并安排虚拟地址到该段位置

虚拟地址是软件开发的 中间层的典型例子, 整个计算机发展就是不断引入新的中间层

### 6.1.2. 编译模式

现代编译器大都提供两种编译模式 : 32位 64位
* 32位下一个指针占用4字节, 即程序的理论虚拟内存大小最大为 4GB 2^32, 跟物理内存没关系
  * 如果物理内存小于程序内存, 那么会进行硬盘写入和读回操作
* 64位编译下, 一个内存占8字节, 尽管理论无限, 但由于物理内存目前没有这么大
  * (重要) 目前 Windows 和 Linux 都对虚拟地址进行了限制, 仅使用虚拟地址的低 48 位 (6字节) = 256TB

### 6.1.3. 地址对齐

* 因为内存地址都是按 字节编号, 而32位和64位CPU可以同时读取 4字节/8字节数据
* 因此CPU的实际寻址的步长为 4/8 字节
* 将数据尽量放在一个步长之内, 避免跨步长寻址, 称为 **内存对齐**
  * 在这过程中有可能会产生内存填充-浪费
* 编译器一般都会自动进行结构体内存对齐
  * 对于不同编译器有不同的实际效果区分
  * GCC 在 Debug 和 Release 模式都会全局变量进行对齐
  * VS 只有在 Release 下才会对全局变量对齐
  * 局部变量都不会对齐

```cpp
struct{
    int a;
    char b;
    int c;
}t;
sizeof(t) // 12
// 对应地址
// B69030
// B69034
// B69038

```
### 6.1.4. 内存分页

如果以程序为单位进行虚拟内存映射, 那么当物理内存不足时, 被换入换出磁盘的是整个程序, 这对于速度的影响非常大, 内存操作的粒度太大. 

现代计算机都使用 分页(Paging) 的方式对虚拟地址空间和物理空间进行分割和映射, 以减少内存操作的粒度.  
* 分页的 每个页面的大小相等, 以页为单位进行磁盘换入换出
  * 页的大小由硬件和操作系统决定
  * 目前大部分操作系统都是 4KB 大小的页
* 对于当前不用的程序数据放在磁盘中, 需要时再读入
* 物理磁盘不足时, 只需要将一部分写入磁盘即可
  * 虚拟空间的页 VP Virtual Page
  * 物理内存的页 PP Physical Page
  * 磁盘中的页   DP Disk Page
* 当程序要访问的页在硬盘而不在内存中时, 硬件可以捕获到这个消息, 发生 **页错误** page fault, 此时操作系统会接管进程, 执行对应的硬盘读入, 映射建立


页表 Page Table 是分页机制的核心:
* 通过给定页数和页内偏移, 即可确定一个物理地址
* 32位程序, 4GB的虚拟内存空间, 需要2^20个页, 即1M个元素的页表, 页表数组总大小为4M字节
  * 每个页数需要 20 位, 而一个数却占32位, 一般直接使用地址的前20位当作页数
  * 地址的后12位就是页内偏移
  * 页表数组的后12位 可以用来记录页的相关属性, 读写权限, 是否已分配物理内存, 是否已移动到磁盘等
    * 如果当前访问的内存无权访问, 则会产生异常, 并交给操作系统处理
    * 操作系统的处理一般比较粗暴, 会直接关闭程序
    * Linux 下会直接产生段错误 `Segment Fault`

多级页表 
* 4M大小的页表对于某些设备仍然过大
* 使用多级页表, 高级的成为 页目录 Page Directory
  * 地址的前10位作为 页目录下标
  * 中10位作为 页表下标
  * 后12位是页内偏移
* 只有极限情况下, 多级页表会占用 4MB+4KB 的内存, 大多数情况下, 因为程序的内存需要较小, 所以页表的个数页也较小, 内存占用少

### 6.1.5. MMU

CPU 内部的 MMU, Memory Management Unit 内存管理单元, 专门负责将虚拟地址转换成物理地址  
* 因为 MMU 在CPU内部, 因此 MMU 对内存的访问会极大影响性能
* 为了加快页表的查找, CPU 在 MMU 模块的内部加入了缓存, 专门用来存储页目录和页表  
  * 经过算法, 可以时 查页表的缓存命中率达到 90%, 剩下 10% 再去物理内存加载页表
  * 页表的构建是页目录的事, MMU 并不会对页表进行修改操作
* 在程序加载到内存并运行的时候:
  * 操作系统会维持程序页目录和页表的更新
  * 并将 页目录的 物理地址保存到CPU 的CR3 寄存器
  * 程序切换的时候, 只需要改变CR3寄存器的值即可找到对应的页表

## 6.2. C语言的内存布局

内存模型 Memory Model : 程序内存在地址空间中的分布情况
* 内存模型由操作系统构建, Linux 和 Windows 下会有所不同
* 编译模式也会影响内存模型

### 6.2.1. 内核空间

* 不管什么位系统或内存模型,  不论如何都需要有一部分给操作系统内核使用
* 这段内存地址就被成为 内核空间 Kernel Space, 高地址即偏向 FFFFFFFF 的部分
* 32位系统下, 4GB理论空间
  * Windows 默认使用高地址的 2G 空间作为内核空间
  * Linux 默认使用 高地址的 1G 空间作为内核空间
* 64位系统下
  * 高地址的 128TB 作为内核空间, 低 128TB 作为用户空间
  * 但由于当前的64位系统只使用 48位地址, 即实际的使用空间更小
    * 对于地址来说 , 还剩高位 4 个16进制数没使用
    * 此时的区分方法, 高16位二进制地址 (48-63) 必须与第 47 地址一致

![图像](http://c.biancheng.net/uploads/allimg/190122/104P51I1-0.jpg)


存在的内存分区
| 分区                   | 说明                                                   |
| ---------------------- | ------------------------------------------------------ |
| 程序代码区 code        | 存放函数体的二进制代码                                 |
| 常量区 Constant        | 存放一般的常量, 只有读取权限, 因此不会被改变值         |
| 全局数据区 Global Data | 全局变量, 静态变量等                                   |
| 堆区 Heap              | 由程序员分配和释放, 未释放的区域在程序结束时由系统回收 |
| 动态链接库             | 动态链接库的分配空间                                   |
| 栈区 Stack             | 存放函数的参数值, 局部变量等                           |

### 6.2.2. Linux 的内存模型

32 位Linux 内存的分配方法 :  (32位系统, 8位16进制字符)
* 保留区域 0x00000000~ 0x08048000
  * 低地址区域一开始的保留区域, 和高地址的内核空间不同
* 大小固定区 0x08048000 开始, 具体大小由程序决定
  * 代码区, 常量区, 全局数据区 在程序加载到内存后就分配好了, 一直存在, 所以全局变量在任何位置都能访问
  * 从低地址开始依次是
    * 程序代码区 只读
    * 常量区     只读
    * 全局数据区 读写
      * 全局变量在内存分配的时候会进行0值化操作
* 堆区 head 从大小固定区开始向上增长 ~ 
  * 堆区是程序员唯一能控制的内存区域
  * 程序员可以自由申请并分配只用
  * 堆内存在程序释放前会一直存在, 即 不会因为函数的结束而失效
  * 在函数内部产生的数据只要放到堆中, 在函数结束后在外面也能使用
* 动态链接库区 0x40000000~ 
  * 动态链接库的保存地址
* 栈区 ~0xC0000000 (注意栈区是向低地址方向增长的)
  * 函数调用时候的 参数, 局部变量, 返回地址等进行压栈
  * 执行后出栈销毁数据
* 内核区

64 位Linux 内存的分配方法 :  16位16进制字符
* 顺序相同
* 保留区域 0~ 0x400000
* 动态链接库 0x 0000 0AAA AAAA A000 
* 栈区 ~ 0x 0000 7FFF FFFF FFFF
* 内核区

### 6.2.3. Windows 的内存模型

Windows 因为是闭源的, 资料较少
* 32位下 高2GB 空间分给内核
* 64位下 高248分给内核, 8TB 分给用户程序

Windows 的内存特性:
* Windows 的地址空间被分配给了各种 exe, dll 文件, 堆, 栈
* 因为每个线程的栈都是独立的, 所以一个进程中有多少个线程, 就有多少个对应的栈
  * 每个线程默认的栈大小是 1MB
* 32位 Windows 的地址空间已经是支离破碎了, 当程序向系统申请堆空间时, 只好从这些剩下的还有没被占用的地址上分配

## 6.3. 进程与内存

进程: 
* 一个可执行程序执行后即为一个进程
  * 程序是指令和数据的集合, 严格意义上来说是静态的概念
  * 进程是程序加载进内存后的活动, 是动态的概念
* 进程拥有独立的地址空间
  * `程序的内存空间` 是不严谨的说法, 因为一个进程对应一个不同的地址空间
  * 甚至会有一个程序可能会创建多个进程

### 内核模式与用户模式

* 操作系统内核也是一个应用程序
  * 相比于不同的用户程序, 内核永远占有相同的内存区域, 和用户程序共享内存
  * 如果让内核处于独立的内存空间, 那么每次系统调用都会发生 进程切换, 损耗巨大
    * 寄存器更新
    * CPU数据缓存失效
    * MMU页表缓存失效
* 因为内核空间存放着操作系统的关键数据, 是所有程序共享的
  * 因此操作系统进制用户程序`直接`访问内核空间
  * 相应的, 操作系统会提供 `系统调用 API`, 称为 System Call
* 用户模式(User Mode  ): 执行用户程序自己的代码时称为用户模式
* 内核模式(Kernel Mode): 用户执行 System Call 会暂停用户程序, 转而执行内核代码, 此时称为内核模式
  * 计算机会经常进行模式切换:
  * 应用程序执行 IO, 内存申请等较为底层的操作时, 执行的都是 System Call
  * 相应的系统操作完成后, 就由内核模式转回了用户模式


从 Intel 80386 开始, 为了安全性和稳定性, CPU 设立了 ring0~3 的4个权限级别
* 目前的操作系统只利用了2个级别
* ring0 对应内核模式, 操作系统的核心, 设备驱动
* ring3, 用户程序, 操作系统的用户接口部分

### 栈与进程

* 栈内存由系统自动分配和释放: 
  * 发生函数调用时就为函数运行时用到的数据分配内存
  * 函数调用结束后就将之前分配的内存全部销毁
  * 所以局部变量, 参数只在当前函数中有效, 不能传递到函数外部
* 栈本质上来说是一段连续的内存
  * 现代CPU通常用寄存器来保留内存栈的地址信息
    * ebp 指向栈底 (Extend Base Pointer)
    * esp 指向栈顶 (Extend Stack Pointer)
  * 因为内存模型中, 程序栈是从高地址向低地址分配的, 所以在压栈时, esp的值会减小, 反之增大
* Stack Overflow
  * 对于用户程序, 栈指的是程序栈, 是每一个线程都有的自己的栈, 而不是内存模型中的栈空间
  * 栈的大小和编译器有关, 可以通过编译器指定栈内存的最大值, 一般是 8M
  * 当程序使用的栈内存大于指定值, 就会发成 stack overflow


栈帧 Stack Frame , 又称活动记录 Activate Record
* 没有栈就没有函数调用
* 发生函数调用时, 会将函数运行需要的 `全部信息` 压入栈中, 这些信息即 栈帧, 包括
  * 参数
  * 函数的返回地址, 即函数执行完成后, 函数调用者继续的代码地址
  * 函数调用者的状态信息, 用于恢复场景
    * ebp, ebx, esi, edi
  * -- 以上三种是关键信息, 会优先入栈, 然后会再分配一块较大的内存区域, 供函数体使用
  * 局部变量
  * 较大的函数返回值
  * -- 
  * 最后将其他的寄存器的值压入栈

编译器相关的栈优化
* 通过寄存器来传递参数, 而不是通过栈, 这样更快
* 较小的函数返回值也可以通过寄存器来传递

# 7. dlfcn.h  显示调用动态链接库

在 C/C++ 程序中显示调用动态链接库时, 无需引入和动态链接库相关的头文件  

```cpp
// 相关头文件
#include <dlfcn.h>

// 读取动态链接库 将库文件装载到内存中, 为后续使用做准备
// 使用 dlopen 函数 filename 参数用于表明目标库文件的存储位置和库名
/*
flag 参数的值有 2 种
    RTLD_NOW：将库文件中所有的资源都载入内存
    RTLD_LAZY：暂时不降库文件中的资源载入内存, 使用时才载入
*/
void *dlopen (const char *filename, int flag);


// dlsym() 函数可以获得指定函数在内存中的位置 , 如果查找失败则返回 NULL
// hanle 参数表示指向已打开库文件的指针
// symbol 参数用于指定目标函数的函数名
void *dlsym(void *handle, char *symbol);

// dlopen() 相对地, 借助 dlclose() 函数可以关闭已打开的动态链接库
// 当函数返回 0 时, 表示函数操作成功；反之, 函数执行失败
// handle 表示已打开的库文件指针
int dlclose (void *handle);


// 查错函数 dlerror() 
// 获得最近一次 dlopen(), dlsym() 或者 dlclose() 函数操作失败的错误信息
const char *dlerror(void);
```
**要点**
* filename 参数
  * 如果用户提供的是以 / 开头, 即以绝对路径表示的文件名, 则函数会前往该路径下查找库文件
  * 反之, 如果用户仅提供文件名, 则该函数会依次前往 `LD_LIBRARY_PATH` 环境变量指定的目录, `/etc/ld.so.cache` 文件中指定的目录, `/usr/lib, /usr/lib64, /lib, /lib64` 等默认搜索路径中查找。
* 目标库彻底释放
  * 调用 dlclose() 函数并不一定会将目标库彻底释放
  * 它只会是目标库的引用计数减 1, 当引用计数减为 0 时, 库文件所占用的资源才会被彻底释放


使用实例
```cpp

//打开库文件
void* handler = dlopen("libmymath.so",RTLD_LAZY);
if(dlerror() != NULL){
    printf("%s",dlerror());
}


//获取库文件中的 add() 函数
int(*add)(int,int)=dlsym(handler,"add");
if(dlerror()!=NULL){
    printf("%s",dlerror());
}

// 通过函数指针使用库函数
int sum=add(1,2);

//关闭库文件
dlclose(handler);

```