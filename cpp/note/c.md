- [1. C 语言](#1-c-语言)
  - [1.1. C语言的版本](#11-c语言的版本)
- [2. C语言复习](#2-c语言复习)
  - [2.1. C语言指针](#21-c语言指针)
    - [2.1.1. 指针的定义](#211-指针的定义)
    - [2.1.2. 数组指针 数组名](#212-数组指针-数组名)
    - [2.1.3. 数组和指针的可交换性 下标[]](#213-数组和指针的可交换性-下标)
    - [2.1.4. C语言字符串](#214-c语言字符串)
    - [2.1.5. 函数中的指针](#215-函数中的指针)
    - [2.1.6. NULL 指针](#216-null-指针)
    - [2.1.7. void 指针](#217-void-指针)
    - [2.1.8. 函数指针](#218-函数指针)
- [3. 预处理命令](#3-预处理命令)
  - [3.1. include](#31-include)
  - [3.2. define 宏定义](#32-define-宏定义)
    - [3.2.1. 带参数的宏定义](#321-带参数的宏定义)
    - [3.2.2. 特殊宏定义](#322-特殊宏定义)
  - [3.3. 条件宏](#33-条件宏)
    - [3.3.1. if](#331-if)
    - [3.3.2. ifdef](#332-ifdef)
  - [3.4. error 报错停止](#34-error-报错停止)
  - [3.5. 预定义宏](#35-预定义宏)
    - [3.5.1. 平台](#351-平台)
    - [3.5.2. 编译模式](#352-编译模式)
- [4. 多文件编程](#4-多文件编程)
  - [4.1. 从 extern 开始](#41-从-extern-开始)
  - [4.2. 防止重复包含头文件](#42-防止重复包含头文件)
  - [4.3. 命名空间](#43-命名空间)
  - [4.4. const 在多文件编程中](#44-const-在多文件编程中)
  - [4.5. 头文件应该写什么](#45-头文件应该写什么)
- [5. dlfcn.h  显示调用动态链接库](#5-dlfcnh--显示调用动态链接库)
# 1. C 语言

## 1.1. C语言的版本

**前身**:
* 1969 : B语言出现, 加入了 `++ --` 运算符, 无数据类型语言
* 1971 : NB (New B) 语言出现, 出现了 `int char arrays pointers`等类型
* 1972 : NB 重命名为 C, 加入了结构体, 预处理命令, 逻辑 `&& ||`, 还有便携 IO
* 1973 : Unix 重写了 C, 加入了 `unsigned long unions` 增加了类型的安全性
* 1978 : C 语言正式诞生

**标准C语言**
* 1983 : ANSI 建立了 `X3J11` 委员会用于制定 C 语言标准
* 1988 : C 语言 2nd 版本发布
* 1989 : ANSI 发布了第一个 C 语言标准 `C89 / ANSIC`, 
* 1990 : ANSI 将 C标准提交到 ISO, 被称为 `C90`
* 1995 : `C95` 加入了宽字符的支持 `wctype`
* 1999 : `C99` 加入 `bool longlong` 等新特性
* 2011 : `C11` 加入了线程意识的内存管理等新特性
* 2018 : `C17` 新特性


**总结**
1. C89/C90
   * 第一个C语言标准通常被称为 `ANSI C`。又由于这个版本是 89 年完成制定的，因此也被称为 C89。
   * 后来 ANSI 把这个标准提交到 ISO（国际化标准组织），1990 年被 ISO 采纳为国际标准，称为 `ISO C`。又因为这个版本是1990年发布的，因此也被称为 C90。
   * 因为 ANSI 与 ISO 的C标准内容基本相同，所以对于C标准，可以称为 ANSI C，也可以说是 ISO C，或者 ANSI / ISO C。  
   * 看到 ANSI C、ISO C、C89、C90，要知道这些标准的内容都是一样的
2. C99
   * 增加了新的关键字，编写了新的库，取消了原有的限制，并于 1999 年形成新的标准——ISO/IEC 9899:1999 标准，通常被成为 C99。
   * 当 GCC 和其它一些商业编译器支持 C99 的大部分特性的時候，微软和 Borland 却似乎对此不感兴趣，或者说没有足够的资源和动力来改进编译器，最终导致不同的编译器在部分语法上存在差异。
3. C11
   * 国际标准化组织（ISO）和国际电工委员会（IEC） 旗下的C语言标准委员会于 2011 年底正式发布  
   * 支持此标准的主流C语言编译器有 GCC、LLVM/Clang、Intel C++ Compile 等。  


C11 标准主要增加了以下内容：
    增加了安全函数，例如 `gets_s()`、`fopen_s()` 等；
    增加了 `<threads.h>` 头文件以支持多线程；
    增加了 `<uchar.h>` 头文件以支持 Unicode 字符集；

* 现有的教程（包括书籍、视频、大学课程等）大都是针对 C89 编写的，这是C语言的核心，后来的 C99、C11 新增的特性并不多，只是在“打补丁”。
* 每次的更新, C 语言都会融合一些 C++的特性作为自己的内容, C和C++相互依存同时还互相学习


# 2. C语言复习



## 2.1. C语言指针

`*` 在不同的场景下有不同的作用：
    1. 表示乘法，例如 `int a = 3, b = 5, c;  c = a * b;` 这是最容易理解的。
    2. `*`可以用在指针变量的定义中，表明这是一个指针变量，以和普通变量区分开；
    3. 使用指针变量时在前面加`*`表示获取指针指向的数据，或者说表示的是指针指向的数据本身

和指针相关的运算符优先级从高到低依次是
1. 定义中被括号( )括起来的那部分。
2. 后缀操作符：括号( )表示这是一个函数，方括号[ ]表示这是一个数组。
3. 前缀操作符：星号`*`表示 “指向xxx的指针”。


### 2.1.1. 指针的定义
```c
// C语言的指针定义符号 * 是后结合的
//a、b、c 的类型都是 int*
int *a, *b, *c;  

// 只有 a 是指针变量，b、c 都是类型为 int 的普通变量
int *a, b, c;
```

### 2.1.2. 数组指针 数组名

* `数组名` 可以 `认为` 是一个指针，它指向数组的第 0 个元素, 数组名和数组首地址并不总是等价
* 如果 p 是指向数组 arr 的指针，那么也可以使用 `p[i]` 来访问数组元素，它等价于 `arr[i]`。 
* 数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变

```cpp
int arr[] = { 99, 15, 100, 888, 252 };

// 可以定义一个指向数组的指针
int *p = arr;
// p 指向数组中的第二个元素
int *p = &arr[2];  //也可以写作 int *p = arr + 2;


// 指针数组   二维数组指针
// [ ]的优先级高于*
int *(p1[5]);  // 指针的数组， 可以去掉括号直接写作 int *p1[5]; 一个有5个元素的数组, 元素类型是 int *
int (*p2)[5];  // 二位数组的指针，不能去掉括号, 一个指针指向了 int[6] 类型, 通过p2+1 代表二位数组下降一行
```

数组名和指针的区别:
1. 求数组的长度，只能使用数组名，不能使用数组指针
2. 用操作符 sizeof 对数组名可以得到整个数组所占用的字节, 而对指针使用只会得到指针占用的字节

与普通变量名相比，数组名既有一般性也有特殊性：
1. 一般性表现在数组名也用来指代特定的内存块，也有类型和长度
2. 特殊性表现在数组名有时候会转换为一个指针，而不是它所指代的数据本身的值。


### 2.1.3. 数组和指针的可交换性 下标[] 


数组是有具体类型的, 定义一个数组 `a[6]`，它的类型是`int [6]` 表示这是一个拥有 6 个 int 数据的集合  

C语言标准规定下列情况时,  数组类型被当作数组类型看待  
1. 当数组名作为数组定义的标识符（也就是定义或声明数组时）
2. sizeof 或 & 的操作数时

除此之外的其他的**所有**表达式中，数组名会被转换为指向第 0 个元素的指针  
这代表以下的函数定义是完全等价的
```cpp
void func(int *parr){ ...... }
void func(int arr[]){ ...... }
void func(int arr[5]){ ...... }
// 用 sizeof(arr) 求得的是指针变量的长度，而不是数组长度
// 要想在函数内部获得数组长度必须额外增加一个参数
```

C语言标准还规定，数组下标`[]` 与指针的偏移量等价  
因此取下标操作符`[]`是建立在指针的基础上的一系列操作的集合:
1. 使一个指针和一个整数相加, 产生出一个新的指针
2. 然后从这个新指针（新地址）上取得数据, 即使用 `*` 运算符
对数组的引用 `a[i]` 在编译时总是被编译器改写成`*(a+i)`的形式，C语言标准也要求编译器**必须**具备这种行为。  

使用下标时，编译器会自动把下标的步长调整到数组元素的大小:  
数组 a 中每个元素都是 int 类型，长度为 4 个字节，那么 `a[i+1]` 和 `a[i]` 在内存中的距离是 4（而不是 1）  


### 2.1.4. C语言字符串

C语言中没有特定的字符串类型，我们通常是将字符串放在一个字符数组中

```cpp

char str[] = "c.biancheng.net";

// 除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串
char *str = "c.biancheng.net";

// 或者
char *str;
str = "c.biancheng.net";

// 指针指向可以更改, 但是不能更改字符串数据
char *str = "Hello World!";
str = "I love C!";  //正确
str[3] = 'P';  //错误
```
两种字符串类型的区别:
1. 在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，指针形式的字符串存储在常量区
2. 全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限
3. 常量区的字符串（也包括其他数据）只有读取权限，没有写入权限.一旦被定义后就只能读取不能修改，任何对它的赋值都是错误的


### 2.1.5. 函数中的指针

函数参数中的数组:
1. C语言没有从语法上支持数据集合的直接赋值
2. 在参数中书写 `int intArr[6]` 还是 `int intArr[]` 都不会创建一个数组出来，编译器也不会为它们分配内存，实际的数组是不存在的，它们最终还是会转换为int *intArr这样的指针
   

函数返回值中的指针
* 函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数
* 函数返回的指针请尽量不要指向这些数据

### 2.1.6. NULL 指针

* 一个指针变量可以指向计算机中的任何一块内存，不管该内存有没有被分配，也不管该内存有没有使用权限，只要把地址给它，它就可以指向
* C语言没有一种机制来保证指向的内存的正确性，程序员必须自己提高警惕


1. NULL 表示空指针，是一个在 `C许多头文件中` 都定义了的宏定义，可以在代码中直接使用
2. NUL 表示字符串的结束标志 '\0'，它是ASCII码表中的第 0 个字符。NUL 没有在C语言中定义，仅仅是对 '\0' 的称呼，不能在代码中直接使用


NULL 在C/C++中的定义
```cpp
// c

// 1. an integer constant expression with the value ​0​
// 2. an integer constant expression with the value 0 cast to the type void* 
// 3. A null pointer constant may be converted to any pointer type; such conversion results in the null pointer value of that type. 

// C++ compatible:
#define NULL 0

// C++ incompatible:
#define NULL (10*2 - 20)
#define NULL ((void*)0)  // 这一条是最二义性的

// -------c++-----
// (since C++11)
// 1. an integer literal with value zero
// 2. or a prvalue of type std::nullptr_t
#define NULL 0

//since C++11
#define NULL nullptr
```
### 2.1.7. void 指针

C语言的 NULL 定义为 `((void *)0)` 这也只存在于C语言

* `void` 用在函数定义中可以表示函数没有返回值或者没有形式参数
* `void *`, 表示指针指向的数据的类型是未知的。
    1. `void *` 表示一个有效指针, 它确实指向实实在在的数据, 它不是空指针的意思, 只是数据的类型尚未确定
    2. C语言动态内存分配函数 `malloc()` 的返回值就是void *类型, 因此C语言的 `malloc()` 在使用时要进行强制类型转换


### 2.1.8. 函数指针

函数指针的定义形式为:  
`returnType (*pointerName)(param list);`  
参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称  


第一个括号不能省略，如果写作
`returnType *pointerName(param list);`  
就成了函数原型，它表明函数的返回值类型为returnType *


定义`pmax` 是一个函数指针，在前面加 * 就表示对它指向的函数进行调用。  
由于( )的优先级高于*， `(*pmax)()` 两个括号不能省略    

# 3. 预处理命令

在编译之前对源文件进行简单加工的过程，就称为预处理  

以`#`号开头的命令称为预处理命令  

1. 预处理 输出 `.i`
2. 编译 输出 `.o`
3. 连接 输出可执行文件

| 指令     | 说明                                                      |
| -------- | --------------------------------------------------------- |
| #        | 空指令，无任何效果                                        |
| #include | 包含一个源代码文件                                        |
| #define  | 定义宏                                                    |
| #undef   | 取消已定义的宏                                            |
| #if      | 如果给定条件为真，则编译下面代码                          |
| #ifdef   | 如果宏已经定义，则编译下面代码                            |
| #ifndef  | 如果宏没有定义，则编译下面代码                            |
| #elif    | 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码 |
| #endif   | 结束一个#if……#else条件编译块                              |


## 3.1. include

`#include` 的处理过程很简单，就是将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。

使用尖括号< >和双引号" "的区别在于头文件的搜索路径不同：

    使用尖括号< >，编译器会到系统路径下查找头文件；
    而使用双引号" "，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。

也就是说，使用双引号比使用尖括号多了一个查找路径，它的功能更为强大。

## 3.2. define 宏定义

`宏定义`, 就是用一个标识符来表示一个字符串, 如果在后面的代码中出现了该标识符, 那么就全部替换成指定的字符串  (**简单粗暴的替换**)  

宏定义的一般形式为:  
`#define  宏名  字符串`  

注意点:  
1. 预处理程序对宏定义不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现
2. 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换
3. 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用`#undef`  
4. 对字符串不进行宏替换的话可以使用 双引号: `""`
5. 宏定义允许嵌套
6. 习惯上宏名用大写字母表示，以便于与变量区别
7. 可用宏定义表示数据类型，使书写方便 `#define UINT unsigned int`

### 3.2.1. 带参数的宏定义

`#define 宏名(形参列表) 字符串`  
* 宏名和形参列表之间不能有空格出现  
* 带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型
* 字符串内的形参通常要用括号括起来以避免出错
  * 不仅要在参数两侧加括号，还应该在整个字符串外加括号

```c
#define MAX(a,b) (a>b) ? a : b

// 错误
#define SQ(y) y*y 

// 错误
#define SQ(y) (y)*(y)

// 正确
#define SQ(y) ((y)*(y))
```
### 3.2.2. 特殊宏定义

在宏定义中的`#`: 用来将宏参数转换为字符串 也就是在带参数宏中的宏参数的开头和末尾添加引号  

```c
#define STR(s) #s

printf("%s", STR(c.biancheng.net));
// 等同于
printf("%s", "c.biancheng.net");

```

`##` 称为连接符，用来将宏参数或其他的串连接起来  

```c
#define CON1(a, b) a##e##b

#define CON2(a, b) a##b##00

printf("%f\n", CON1(8.5, 2));
printf("%d\n", CON2(12, 34));

// 等同于
printf("%f\n", 8.5e2);
printf("%d\n", 123400);
```

## 3.3. 条件宏

条件编译是预处理程序的功能，不是编译器的功能。  

### 3.3.1. if

* `#if`     命令要求判断条件为“整型常量表达式”，也就是说，表达式中不能包含变量，而且结果必须是整数
* `if`      的表达式没有限制，只要符合语法就行
```c
#if 整型常量表达式1
    程序段1

#elif 整型常量表达式2
    程序段2

#elif 整型常量表达式3
    程序段3

#else
    程序段4

#endif

```

### 3.3.2. ifdef

* #ifdef:   如果当前的宏已被定义过，则对“程序段1”进行编译，否则对“程序段2”进行编译。  
* #ifndef:  如果当前的宏未被定义，则对“程序段1”进行编译，否则对“程序段2”进行编译，这与 #ifdef 的功能正好相反。

```cpp
#ifdef  宏名
    程序段1
#else
    程序段2
#endif
```

## 3.4. error 报错停止

`#error` 指令用于在编译期间产生错误信息 **并阻止程序的编译** , 其形式如下：  
`#error error_message`   

注意报错信息不需要加引号" "  

```c
#ifdef WIN32
#error This programme cannot compile at Windows Platform
#endif

#ifndef __cplusplus
#error 当前程序必须以C++方式编译
#endif

```
## 3.5. 预定义宏

预定义宏就是已经预先定义好的宏，我们可以直接使用，无需再重新定义  

| 宏名          | 功能                                            |
| ------------- | ----------------------------------------------- |
| `__LINE__`    | 表示当前源代码的行号；                          |
| `__FILE__`    | 表示当前源文件的名称；                          |
| `__DATE__`    | 表示当前的编译日期；                            |
| `__TIME__`    | 表示当前的编译时间；                            |
| `__STDC__`    | 当要求程序严格遵循ANSI C标准时该标识被赋值为1； |
| `__cplusplus` | 当编写C++程序时该标识符被定义。                 |

```c

printf("Date : %s\n", __DATE__);
// Date : Mar  6 2016
printf("Time : %s\n", __TIME__);
// Time : 11:47:15
printf("File : %s\n", __FILE__);
// File : main.c
// File : C:\Users\mozhiyan\Desktop\demo.c
printf("Line : %d\n", __LINE__);
// Line : 8

```
### 3.5.1. 平台

* Windows 有专有的宏    `_WIN32`
* Linux 有专有的宏      `__linux__`

```c
//不同的平台下引入不同的头文件
#if _WIN32  //识别windows平台
#include <windows.h>

#elif __linux__  //识别linux平台
#include <unistd.h>

#endif
```
### 3.5.2. 编译模式

VS/VC 有两种编译模式，Debug 和 Release  会定义对应的宏  
* `_DEBUG`

```c
#ifdef _DEBUG
    printf("正在使用 Debug 模式编译程序...\n");
#else
    printf("正在使用 Release 模式编译程序...\n");
#endif
```

# 4. 多文件编程

一个完整的 C++ 项目常常是由多个代码文件组成的，根据后缀名的不同，大致可以将它们分为如下 2 类：
* .h 文件：又称“头文件”，用于存放常量、函数的声明部分、类的声明部分；
* .cpp 文件：又称“源文件”，用于存放变量、函数的定义部分，类的实现部分。
注意，引入编译器自带的头文件（包括标准头文件）用尖括号，例如 `<iostream>`；引入自定义的头文件用 "" 双引号，例如 `"student.h"`。 


实际上, 除了后缀不一样便于区分和管理外，其他的几乎相同，在 .cpp 中编写的代码同样也可以写在 .h 中。  
之所以将 .cpp 文件和 .h 文件在项目中承担的角色进行区别，不是 C++ 语法的规定，而是约定成俗的规范.  

1. 虽然类内部的成员函数可以在声明的同时进行定义（自动成为内联函数），但原则上不推荐这样使用。
   也就是说，即便定义成员函数的代码很少，其定义也应该放在适当的 .cpp 文件中。
2. 对于一些系统提供的库，出于版权和保密的考虑，大多是已经编译好的二进制文件，其中可能仅包含 .h 文件，而没有 .cpp 文件。

## 4.1. 从 extern 开始

1. 在实际开发中，经常会在函数或变量定义之前就使用它们，这个时候就需要提前声明。
2. 所谓声明（Declaration），就是告诉编译器我要使用这个变量或函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。

对于函数来说: 函数的定义有函数体，函数的声明没有函数体，编译器很容易区分定义和声明，所以对于函数声明来说，有没有 extern 都是一样的。  
对于变量来说: 编译器只能根据 extern 来区分，有 extern 才是声明，没有 extern 就是定义。  

变量的声明只有一种形式，就是使用 extern 关键字：
```cpp
// 变量的声明
extern datatype name;
// 声明的同时初始化 但是没有实际意义
extern datatype name = value;
```
extern 是“外部”的意思，很多教材讲到，extern 用来声明一个外部（其他文件中）的变量或函数，也就是说，变量或函数的定义在`其他文件`中。    
但是除了定义在外部，定义在当前文件中也是正确的。  
因此本质上 extern 是用来声明的，不管具体的定义是在当前文件内部还是外部，都是正确的。  

## 4.2. 防止重复包含头文件 

1. 头文件包含命令 #include 的效果与直接复制粘贴头文件内容的效果是一样的，预处理器实际上也是这样做的，
   它会读取头文件的内容，然后输出到 #include 命令所在的位置。  
2. 头文件包含是一个递归（循环）的过程，如果被包含的头文件中还包含了其他的头文件，预处理器会继续将它们也包含进来；
   这个过程会一直持续下去，直到不再包含任何头文件，这与递归的过程颇为相似。

C++ 多文件编程中，处理多次 `#include` 导致重复引入”问题的方式有 3 种
1. 使用宏定义避免重复引入
   * #ifndef 是通过定义独一无二的宏来避免重复引入的，这意味着每次引入头文件都要进行识别，所以效率不高。
   * 但考虑到 C 和 C++ 都支持宏定义，所以项目中使用 `#ifndef` 规避可能出现的“头文件重复引入”问题，不会影响项目的可移植性。
2. 使用`#pragma once`避免重复引入
   * 一些较老版本的编译器不支持该指令
   * 但是实际中在 C/C++ ，#pragma once 是一个非标准但却逐渐被很多编译器支持的指令。
3. 使用_Pragma操作符 (C99)
   * 可以看做是 `#pragma` 的增强版，不仅可以实现 `#pragma` 所有的功能，更重要的是，`_Pragma` 还能和宏搭配使用。
   * _Pragma 和 #pragma 有很多其他用法
4. 实际使用中
   * 强烈推荐读者选用第1种解决方案，即采用 `#ifndef / #define / #endif`组合解决头文件被重复引入。
   * 同时考虑到编译效率和可移植性，#pragma once 和 #ifndef 经常被结合使用
   * 当编译器可以识别 #pragma once 时，则整个文件仅被编译一次；反之，即便编译器不识别 #pragma once 指令，此时仍有 #ifndef 在发挥作用。


```cpp
// 宏保护的具体写法

// 这里 文件名为 xyz.h
#ifndef _XYZ_H
#define _XYZ_H
/* 具体的头文件内容 */
#endif
// 这样只要有任意一个文件包含了 `#include "xyz.h"` 则宏就会被定义, 之后的文件再包含也不会造成重复定义


// **pragma 的用法**

// 注意 #pragma once 是针对整个文件的
#pragma once
class Student {
  //......
};

// 或者
_Pragma("once")
class Student {
  //......
};

// 组合使用也可以
#pragma once
#ifndef _STUDENT_H
#define _STUDENT_H
class Student {
   //......
};
#endif
```

## 4.3. 命名空间

1. 不同头文件中也可以使用名称相同的命名空间，但前提是位于该命名空间中的成员必须保证互不相同。
2. 当类的声明位于指定的命名空间中时，如果要在类的外部实现其成员方法，需同时注明**所在命名空间名和类名**  `Li::Student::display() `
3. C++ 中 `display()` 和 `display(int n)` 并不会造成重定义，它们互为重载函数

## 4.4. const 在多文件编程中

1. 用 const 修饰的变量必须在定义的同时进行初始化操作
2. const 关键字除了表明其修饰的变量为常量外  还将所修饰变量的 `可见范围限制为当前文件`  
   因此除非 const 常量的定义和 main 主函数位于同一个 `.cpp` 文件，否则该 const 常量只能在其所在的 `.cpp` 文件中使用

三种在多文件编程中使用其他文件中的 const 常量的方法  
第一种方式更简单、更常用  习惯什么的都别在意  

1. 将const常量定义在.h头文件中  最常用也最简单的方法

此方式违背了“声明位于 .h 文件，定义（实现）位于 .cpp 文件”的规律.
但是实际上还有别的习惯也是违背这个规律的 分别是 类的定义和内联函数的定义，通常情况下它们也都定义在 .h 文件中。
```cpp
//demo.h
#ifndef _DEMO_H
#define _DEMO_H
const int num = 10;
#endif

```
2. 借助extern先声明再定义const常量

借助 extern 关键字 , 就可以遵守 “声明位于 .h 文件，定义（实现）位于 .cpp 文件”的规律  
定义在 h 头文件中的 extern const 可以将 常量的作用范围恢复到整个文件  

```cpp
//demo.h
#ifndef _DEMO_H
#define _DEMO_H
extern const int num;  //声明 const 常量
#endif

//demo.cpp
#include "demo.h"   //一定要引入该头文件
const int num =10; // 定义
```

3. 借助extern直接定义const常量

在第2种的基础上进一步优化,直接省略掉头文件的建立, 但是这不符合编程结构习惯  
```cpp
//demo.cpp
extern const int num =10;

//main.cpp
extern const int num;
int main() {
  std::cout << num << std::endl;
  return 0;
}
```
## 4.5. 头文件应该写什么

因为声明语句是可以重复的
1. 区分普通函数和变量的声明和定义
2. 头文件中可以定义 const 对象和 static 对象
3. 头文件中可以定义内联函数 （用 inline 修饰的函数）
4. 头文件中可以定义类

```cpp
// 变量和函数的声明
extern int a;
void f();

// 定义 要区分好
int a;
void f() {}

// 成员变量是要等到具体的对象被创建时才会被定义（分配空间）
// 因此成员变量放在头文件中，而把成员函数的实现代码放在一个 .cpp 文件中
class a{
    int a;
}
```
# 5. dlfcn.h  显示调用动态链接库

在 C/C++ 程序中显示调用动态链接库时，无需引入和动态链接库相关的头文件  

```cpp
// 相关头文件
#include <dlfcn.h>

// 读取动态链接库 将库文件装载到内存中，为后续使用做准备
// 使用 dlopen 函数 filename 参数用于表明目标库文件的存储位置和库名
/*
flag 参数的值有 2 种
    RTLD_NOW：将库文件中所有的资源都载入内存
    RTLD_LAZY：暂时不降库文件中的资源载入内存，使用时才载入
*/
void *dlopen (const char *filename, int flag);


// dlsym() 函数可以获得指定函数在内存中的位置 , 如果查找失败则返回 NULL
// hanle 参数表示指向已打开库文件的指针
// symbol 参数用于指定目标函数的函数名
void *dlsym(void *handle, char *symbol);

// dlopen() 相对地，借助 dlclose() 函数可以关闭已打开的动态链接库
// 当函数返回 0 时，表示函数操作成功；反之，函数执行失败
// handle 表示已打开的库文件指针
int dlclose (void *handle);


// 查错函数 dlerror() 
// 获得最近一次 dlopen()、dlsym() 或者 dlclose() 函数操作失败的错误信息
const char *dlerror(void);
```
**要点**
* filename 参数
  * 如果用户提供的是以 / 开头，即以绝对路径表示的文件名，则函数会前往该路径下查找库文件
  * 反之，如果用户仅提供文件名，则该函数会依次前往 `LD_LIBRARY_PATH` 环境变量指定的目录、`/etc/ld.so.cache` 文件中指定的目录、`/usr/lib、/usr/lib64、/lib、/lib64` 等默认搜索路径中查找。
* 目标库彻底释放
  * 调用 dlclose() 函数并不一定会将目标库彻底释放
  * 它只会是目标库的引用计数减 1，当引用计数减为 0 时，库文件所占用的资源才会被彻底释放


使用实例
```cpp

//打开库文件
void* handler = dlopen("libmymath.so",RTLD_LAZY);
if(dlerror() != NULL){
    printf("%s",dlerror());
}


//获取库文件中的 add() 函数
int(*add)(int,int)=dlsym(handler,"add");
if(dlerror()!=NULL){
    printf("%s",dlerror());
}

// 通过函数指针使用库函数
int sum=add(1,2);

//关闭库文件
dlclose(handler);

```