# 1. C++11标准

C++11 标准对 C++ 语言增添了约 140 个新特性

# C++11 空指针

nullptr是C++11版本中新加入的，它的出现是为了解决NULL表示空指针在C++中具有二义性的问题  

C++中关于空指针的定义  
```c++
// C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种

// 将指针明确指向 0（0x0000 0000）这个内存空间。一方面，明确指针的指向可以避免其成为野指针；
// 另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。
int *p2 = 0;

// 值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）
int *p1 = NULL; // 需要引入cstdlib头文件

int *p3 = nullptr;
```

1. 关于NULL的定义
   在C++中,NULL被直接定义成整数0  
   而在C中,NULL的定义为 `#define NULL ((void *)0)`,也就是说NULL实际上是一个void* 指针  
   造成这种差异的原因是为了照顾C++的函数重载  
```Cpp
void Func(char *);
void Func(int);

int main()
{
    //C语言没有重载, 是弱类型语言,因此可以允许void*进行隐式转换  
    //C++为了重载, 是强类型语言,因此不允许void*的隐式重载, 将NULL更改为了整数0  
    //而根据传统思维, NULL应该代表的是char* , 但是因为C++中NULL就是整数0, 所以实际执行的是int的函数
    Func(NULL);
}
```
2. nullptr的使用
   注意`nullptr`是在C++11中引入的  
   nullptr可以转化为任意的指针和布尔值, 但是不能转变为整数  

# 2. C++11 的 右值引用 移动 转发
## 2.1. 右值引用

C++11 新增了一种引用，可以引用右值，因而称为“右值引用”。  
无名的临时变量不能出现在赋值号左边，因而是右值。右值引用就可以引用无名的临时变量。  

能出现在赋值号左边的表达式称为“左值”，不能出现在赋值号左边的表达式称为“右值”。
1. 左值是可以取地址
2. 右值则不可以

* 非 const 的变量都是左值。
* 函数调用的返回值若不是引用，则该函数调用就是右值。
* 一般所学的“引用”都是引用变量的，而变量是左值，因此它们都是“左值引用”.

左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是"left value"、"right value" 的缩写，其实不然。  
`lvalue` 是 `loactor value` 的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据.   
`rvalue` 译为 ` read value` ，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。  


引用类型        可以引用的值类型 	                         使用场景  
                非常量左值 常量左值 非常量右值 常量右值   
非常量左值引用      Y         N   	    N        N 	        无
常量左值引用        Y         Y   	    Y        Y 	        常用于类中构建拷贝构造函数  
非常量右值引用      N         N   	    Y        N          移动语义、完美转发
常量右值引用        N         N   	    Y        Y          无实际用途

### 2.1.1. 定义

右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。  
C++11 标准新引入了另一种引用方式，称为右值引用，用 `&&` 表示。    


```cpp
// 传统的引用定义
// C++98/03 标准不支持为右值建立非常量左值引用  
int num = 10;
int &b = num; //正确
int &c = 10; //错误

// 但是支持常量引用
int num = 10;
const int &b = num;
const int &c = 10;


// C++11 的右值引用定义
//类型 && 引用名 = 右值表达式;
int num = 10;
//int && a = num;  //右值引用不能初始化为左值
int && a = 10;

// 使用了右值引用就可以对右值进行修改
int && a = 10;
a = 100;
cout << a << endl;


class A{};
A & rl = A();  //错误，无名临时变量 A() 是右值，因此不能初始化左值引用 r1
A && r2 = A();  //正确，因 r2 是右值引用

```



### 2.1.2. 使用场景

引入右值引用的主要目的是提高程序运行的效率。有些对象在复制时需要进行深复制，深复制往往非常耗时。合理使用右值引用可以避免没有必要的深复制操作。  
右值引用主要用于实现移动（move）语义和完美转发  


## 2.2. 移动构造函数

知道了右值引用,就可以学习移动构造函数 ,引入了右值引用的语法，借助它可以实现移动语义。   

### 2.2.1. 定义
在 C++ 11 标准之前（C++ 98/03 标准中），如果想用其它对象初始化一个同类的新对象，只能借助类中的复制（拷贝）构造函数。  

需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。  
即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦`多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次`，这是不允许的。  


移动构造函数的目的, 是解决函数的无用拷贝  
1. `return demo()`  时, `demo()`  构造函数产生一个匿名对象, 然后复制给返回值对象, 匿名对象析构
2. `a = get_demo()` 时, 又从返回值对象执行复制给a, 然后返回值对象析构
假如 `demo()` 类需要深拷贝,那么一个初始化操作就执行了2次无用拷贝  
事实上, 编译器对这些过程做了专门的优化, 如果使用 VS 2017、codeblocks 等这些编译器运行此程序时，则不会有以上两次无用拷贝, 且并不会影响程序的正确性，因此很少进入程序员的视野。  

此问题一直存留在以 C++ 98/03 标准编写的 C++ 程序中.



### 2.2.2. 使用方法

当类中同时包含拷贝构造函数和移动构造函数时
1. 如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作
2. 只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。
   
在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数
1. 由此当用户利用右值初始化类对象时，会调用移动构造函数
2. 使用左值（非右值）初始化类对象时，会调用拷贝构造函数。

```cpp

//初始化构造函数
demo():num(new int(0)){
     cout<<"construct!"<<endl;
}


//拷贝构造函数 深拷贝
demo(const demo &d):num(new int(*d.num)){
    cout<<"copy construct!"<<endl;
}

//添加移动构造函数
demo(demo &&d):num(d.num){
    // 将原本对象的 指针成员置空, 防止对象析构的时候多次释放空间  
    d.num = NULL;
    cout<<"move construct!"<<endl;
}
```


如果使用左值初始化同类对象，但也想调用移动构造函数完成的时候
1. 默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。
2. C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。 

## 2.3. move()函数 将左值强制转换为右值

* C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。  
* 那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，想使用移动构造函数则可以调用 move() 函数。

move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。   

move() 函数的用法也很简单，其语法格式如下：  
`move( arg )`  
其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。  

使用move来实现传统的 swap函数:
```cpp
void MoveSwap(T & a, T & b) {
    T tmp(move(a));  //std::move(a) 为右值，这里会调用移动构造函数
    a = move(b);  //move(b) 为右值，因此这里会调用移动赋值号
    b = move(tmp);  //move(tmp) 为右值，因此这里会调用移动赋值号
}
```

## 2.4. 完美转发 forward()
 
完美转发: 指的是函数模板可以将自己的参数“完美”地转发给内部调用的其它函数。  
所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的`左、右值属性`不变。  

如果使用 C++ 98/03 标准下的 C++ 语言，我们可以采用函数模板重载的方式实现完美转发  
使用重载的模板函数实现完美转发也是有弊端的，此实现方式仅适用于模板函数仅有少量参数的情况，否则就需要编写大量的重载函数模板，造成代码的冗余。  

没有完美转发的代码:  
```cpp
template<typename T>
void function(T t) {
    otherdef(t);
}
// 在此情况下, 无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值
// 此外, 参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作
```
如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值  
反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值  


为了方便用户更快速地实现完美转发，C++ 11 标准中允许在函数模板中使用右值引用来实现完美转发。
C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。
* 但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为`万能引用`）  
* 由于引用折叠规则存在, 读者只需要知道，在实现完美转发时，只要函数模板的参数类型为 T&&，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。


对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值, 为了完美转发给函数内部的函数  
C++11新标准还引入了一个模板函数 `forword<T>()`

使用C++11特性修改后的完美转发
```cpp
template <typename T>
void function(T&& t) {  // 仅仅只是用了右值引用作为参数
    otherdef(forward<T>(t));
}
```

总的来说，在定义模板函数时，我们采用右值引用的语法格式定义参数类型，由此该函数既可以接收外界传入的左值，也可以接收右值  
其次，还需要使用 C++11 标准库提供的 forword() 模板函数修饰被调用函数中需要维持左、右值属性的参数。由此即可轻松实现函数模板中参数的完美转发。   

