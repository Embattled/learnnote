# 1. C++11标准

C++11 标准对 C++ 语言增添了约 140 个新特性




# 2. C++11 的 右值引用 移动 转发
## 2.1. 右值引用

C++11 新增了一种引用，可以引用右值，因而称为“右值引用”。  
无名的临时变量不能出现在赋值号左边，因而是右值。右值引用就可以引用无名的临时变量。  

能出现在赋值号左边的表达式称为“左值”，不能出现在赋值号左边的表达式称为“右值”。
1. 左值是可以取地址
2. 右值则不可以

* 非 const 的变量都是左值。
* 函数调用的返回值若不是引用，则该函数调用就是右值。
* 一般所学的“引用”都是引用变量的，而变量是左值，因此它们都是“左值引用”.

左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是"left value"、"right value" 的缩写，其实不然。  
`lvalue` 是 `loactor value` 的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据.   
`rvalue` 译为 ` read value` ，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。  


引用类型        可以引用的值类型 	                         使用场景  
                非常量左值 常量左值 非常量右值 常量右值   
非常量左值引用      Y         N   	    N        N 	        无
常量左值引用        Y         Y   	    Y        Y 	        常用于类中构建拷贝构造函数  
非常量右值引用      N         N   	    Y        N          移动语义、完美转发
常量右值引用        N         N   	    Y        Y          无实际用途

### 2.1.1. 定义

右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。  
C++11 标准新引入了另一种引用方式，称为右值引用，用 `&&` 表示。    


```cpp
// 传统的引用定义
// C++98/03 标准不支持为右值建立非常量左值引用  
int num = 10;
int &b = num; //正确
int &c = 10; //错误

// 但是支持常量引用
int num = 10;
const int &b = num;
const int &c = 10;


// C++11 的右值引用定义
//类型 && 引用名 = 右值表达式;
int num = 10;
//int && a = num;  //右值引用不能初始化为左值
int && a = 10;

// 使用了右值引用就可以对右值进行修改
int && a = 10;
a = 100;
cout << a << endl;


class A{};
A & rl = A();  //错误，无名临时变量 A() 是右值，因此不能初始化左值引用 r1
A && r2 = A();  //正确，因 r2 是右值引用

```



### 2.1.2. 使用场景

引入右值引用的主要目的是提高程序运行的效率。有些对象在复制时需要进行深复制，深复制往往非常耗时。合理使用右值引用可以避免没有必要的深复制操作。  
右值引用主要用于实现移动（move）语义和完美转发  


## 2.2. 移动构造函数

知道了右值引用,就可以学习移动构造函数 ,引入了右值引用的语法，借助它可以实现移动语义。   

### 2.2.1. 定义
在 C++ 11 标准之前（C++ 98/03 标准中），如果想用其它对象初始化一个同类的新对象，只能借助类中的复制（拷贝）构造函数。  

需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。  
即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦`多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次`，这是不允许的。  


移动构造函数的目的, 是解决函数的无用拷贝  
1. `return demo()`  时, `demo()`  构造函数产生一个匿名对象, 然后复制给返回值对象, 匿名对象析构
2. `a = get_demo()` 时, 又从返回值对象执行复制给a, 然后返回值对象析构
假如 `demo()` 类需要深拷贝,那么一个初始化操作就执行了2次无用拷贝  
事实上, 编译器对这些过程做了专门的优化, 如果使用 VS 2017、codeblocks 等这些编译器运行此程序时，则不会有以上两次无用拷贝, 且并不会影响程序的正确性，因此很少进入程序员的视野。  

此问题一直存留在以 C++ 98/03 标准编写的 C++ 程序中.



### 2.2.2. 使用方法

当类中同时包含拷贝构造函数和移动构造函数时
1. 如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作
2. 只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。
   
在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数
1. 由此当用户利用右值初始化类对象时，会调用移动构造函数
2. 使用左值（非右值）初始化类对象时，会调用拷贝构造函数。

```cpp

//初始化构造函数
demo():num(new int(0)){
     cout<<"construct!"<<endl;
}


//拷贝构造函数 深拷贝
demo(const demo &d):num(new int(*d.num)){
    cout<<"copy construct!"<<endl;
}

//添加移动构造函数
demo(demo &&d):num(d.num){
    // 将原本对象的 指针成员置空, 防止对象析构的时候多次释放空间  
    d.num = NULL;
    cout<<"move construct!"<<endl;
}
```


如果使用左值初始化同类对象，但也想调用移动构造函数完成的时候
1. 默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。
2. C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。 

## move()函数 将左值强制转换为右值

* C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。  
* 那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，即调用 move() 函数。

move 本意为 "移动"，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。   

move() 函数的用法也很简单，其语法格式如下：  
`move( arg )`  
其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。  

使用move来实现传统的 swap函数:
```cpp
void MoveSwap(T & a, T & b) {
    T tmp(move(a));  //std::move(a) 为右值，这里会调用移动构造函数
    a = move(b);  //move(b) 为右值，因此这里会调用移动赋值号
    b = move(tmp);  //move(tmp) 为右值，因此这里会调用移动赋值号
}
```

