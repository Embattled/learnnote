# 1. Linux 下的CPP开发 gcc g++

## 1.1. 关联与区别

1. 后缀为 `.c` 的文件, gcc当成 `C` 代码 , 而g++会当成 `CPP` 代码
   gcc不会定义 `__cplusplus` 宏 ,而g++会 , 这个宏标志着编译器会把代码按照C还是C++语法来解释,如果后缀为`.c`,并且采用gcc编译器,啧该宏就是未定义的
2. gcc不能**自动**和CPP的库链接,所以通常用g++来完成链接
例程:
```cpp
#include <iostream>
int main(){}
// HelloWorld.cpp
```
两种编译方法
```shell
$ g++ HelloWorld.cpp -o a.out # 使用g++可以直接编译链接

$ gcc -xc++ -lstdc++ -shared-libgcc HelloWorld.cpp -o a.out # 使用gcc需要加上链接的库

```
可以这样认为，`g++` 指令就等同于`gcc -xc++ -lstdc++ -shared-libgcc`指令  

GCC可以自动识别文件扩展名, 匹配类型.  
如果当前文件的扩展名和识别表不符，只需要借助 `-x` 选项（小写）指明当前文件的类型即可。
    通过为 gcc 指令添加 -xc 选项，表明当前 demo 为 C 语言程序文件  
    -x 指令还是后跟 c-header（C语言头文件）、c++（C++源文件）、c++-header（C++程序头文件）等选项

## 1.2. 常用编译命令
| gcc/g++指令选项 | 功 能                                                                               |
| --------------- | ----------------------------------------------------------------------------------- |
| -E（大写）      | 预处理指定的源文件，不进行编译。                                                    |
| -S（大写）      | 编译指定的源文件，但是不进行汇编。                                                  |
| -c              | 编译、汇编指定的源文件，但是不进行链接。                                            |
| -o              | 指定生成文件的文件名。                                                              |
| -ansi           | 对于 C 语言程序来说，其等价于 -std=c90；对于 C++ 程序来说，其等价于 -std=c++98。    |
| -std=           | 手动指令编程语言所遵循的标准，例如 c89、c90、c++98、c++11 等。                      |
| -l`library`     | library 表示要搜索的库文件的名称, 建议 -l 和库文件名之间不使用空格，比如 -lstdc++。 |

## 1.3. gcc编译

基础编译:
```shell
# 只编译 不链接
gcc -c hello.cpp 

# 链接或者直接编译出二进制
gcc hello.cpp

# 指定输出文件
gcc -o hello hello.cpp

# 严格编译 , 输出信息多
gcc hello.c -Wall
```

带链接的编译:
```shell
# 对于cpp文件 , 填入库相关的路径
gcc -lstdc++ hello.cpp

# 对于c文件 
gcc hello.c -lm -L /usr/lib -l /usr/include
```
* -lm 指的是libm.so或libm.a这个函数库文件；
* -L 后面接的路径是刚才上面那个函数库的搜索目录；
* -I 后面的是源码内的include文件所在的目录；

### 1.3.1. 分步编译

1. 预处理  `-E`
   `g++ -E demo.cpp -o demo.i`  
   必须使用 -o 选项将该结果输出到指定的 demo.i 文件  
   Linux 系统中，通常用 ".i" 或者 ".ii" 作为 C++ 程序预处理后所得文件的后缀名  
2. 编译 `-S`   编译阶段针对的将不再是 demo.cpp 源文件，而是 demo.i 预处理文件  
   `g++ -S demo.i`  
    生成对应的`.s`文件, Linux 发行版通常以 ".s" 作为其后缀名  
    和预处理阶段不同，即便这里不使用 -o 选项，编译结果也会输出到和预处理文件同名（后缀名改为 .s）的新建文件中  
3. 汇编  `-c`  
   通过给 g++ 指令添加 -c 选项，即可令 GCC 编译器仅对指定的汇编代码文件做汇编操  
   ` g++ -c demo.s`  
   默认情况下汇编操作会自动生成一个和汇编代码文件名称相同、后缀名为 .o 的二进制文件（又称为目标文件）
4. 链接  
   完成链接操作，并不需要给 g++ 添加任何选项  

## 1.4. 链接

在 Linux 发行版系统中，静态链接库文件的后缀名通常用 .a 表示；在 Windows 系统中，静态链接库文件的后缀名为 .lib  
动态链接库的后缀名通常用 .so 表示；在 Windows 系统中，动态链接库的后缀名为 .dll  

### 1.4.1. 标准库的链接

标准库的大部分函数通常放在文件 `libc.a`  中（文件名后缀.a代表“achieve”，译为“获取”）   
或者放在用于共享的动态链接文件 `libc.so` 中（文件名后缀.so代表“share object”，译为“共享对象”）  
这些链接库一般位于 /lib/ 或 /usr/lib/，或者位于 GCC 默认搜索的其他目录。


当使用 GCC 编译和链接程序时，GCC 默认会链接 libc.a 或者 libc.so，但是对于其他的库（例如`非标准库、第三方库`等），就需要手动添加。  


标准头文件` <math.h>` 对应的数学库默认也不会被链接  
数学库的文件名是 libm.a。前缀lib和后缀.a是标准的，m是基本名称  
GCC 会在-l选项后紧跟着的基本名称的基础上自动添加这些前缀、后缀，本例中，基本名称为 m  
`gcc main.c -o main.out -lm`  

通常，GCC 会自动在标准库目录中搜索文件，例如 /usr/lib，如果想链接其它目录中的库，就得特别指明。有三种方式可以链接在 GCC 搜索路径以外的链接库  
1. 把链接库作为一般的目标文件，为 GCC 指定该链接库的完整路径与文件名
   如果链接库名为 `libm.a`，并且位于 `/usr/lib` 目录，那么下面的命令会让 GCC 编译 main.c，然后将 libm.a 链接到 main.o  
   `gcc main.c -o main.out /usr/lib/libm.a`  
2. 使用-L选项，为 GCC 增加另一个搜索链接库的目录, 再在其后面接上要链接的库名  
   `gcc main.c -o main.out -L/usr/lib -lm`  
   可以使用多个-L选项，或者在一个-L选项内使用冒号分割的路径列表  
3. 把包括所需链接库的目录加到环境变量 LIBRARYPATH 中

### 1.4.2. 自己的链接库

当把程序链接到一个`链接库`时，只会链接程序所用到的函数的目标文件。在已编译的目标文件之外，如果创建自己的链接库，可以使用 ar 命令。

1. 创建自己的静态库  
   可以被加工成静态库的文件:  
   * 源文件中只提供可以重复使用的代码，例如函数、设计好的类等，不能包含 main 主函数
   * 源文件在实现具备模块功能的同时，还要提供访问它的接口，也就是`包含各个功能模块声明部分的头文件`  

    步骤
    1. 将所有指定的源文件，都编译成相应的目标文件
       `gcc -c sub.c add.c div.c`  
    2. 然后使用 ar 压缩指令，将生成的目标文件打包成静态链接库，其基本格式如下  
       `ar rcs 静态链接库名称 目标文件1 目标文件2 `  
       `ar rcs libmymath.a add.o sub.o div.o`  
       静态链接库的不能随意起名，需遵循如下的命名规则 `libxxx.a`  Windows 系统下，静态链接库的后缀名为 `.lib`  

   此时想使用自己的静态库 , 可以使用命令  
   ` gcc -static main.o libmymath.a`  
   使用动态库的命令
   `gcc main.c  libmymath.so -o main.exe`  
   `-static` 选项强制 GCC 编译器使用静态链接库  

   对于别的目录下的库, 使用组合命令 `-L` 和 `-l`  ,分别指定目录和库名  
  `gcc main.o -static -L /root/demo/ -lmymath`  
  
2. 创建自己的动态库  

    **直接使用源文件创建动态链接库**  
    `gcc -fpic -shared 源文件名... -o 动态链接库名`  
    * -shared 选项用于生成动态链接库
    * -fpic （还可写成 -fPIC）: 令 GCC 编译器生成动态链接库（多个目标文件的压缩包）时，表示各目标文件中函数、类等功能模块的地址使用相对地址，而非绝对地址。这样，无论将来链接库被加载到内存的什么位置，都可以正常使用
  

    **从目标文件编译成动态链接库**
    为了后续生成动态链接库并能正常使用，将源文件编译为目标文件时，也需要使用 -fpic 选项  
    `gcc -c -fpic add.c sub.c div.c`  

    ` gcc -shared add.o sub.o div.o -o libmymath.so`  

    **使用动态库进行链接的命令**  
    `gcc main.c  libmymath.so -o main.exe`  

   
   动态库应用程序的查看  
   `ldd main.exe`  可以查看查看当前文件在执行时需要用到的所有动态链接库，以及各个库文件的存储位置  
   
   运行由动态链接库生成的可执行文件时，必须确保程序在运行时可以找到这个动态链接库。常用的解决方案有如下几种：

   * 将链接库文件移动到标准库目录下（例如 /usr/lib、/usr/lib64、/lib、/lib64）；
   * 在终端输入 `export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx` 其中 xxx 为动态链接库文件的绝对存储路径
     （此方式仅当前终端有效，关闭终端后无效）；
   * 修改 ~/.bashrc 或~/.bash_profile 文件 在文件最后一行添加上一个方法的内容 即
     `export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xx` 
     保存之后，执行source .bashrc指令（此方式仅对当前登陆用户有效）。

### 1.4.3. 动态链接库的显式调用

动态链接库的调用方式有 2 种，分别是：
* 隐式调用（静态调用）：将动态链接库和其它源程序文件（或者目标文件）一起参与链接
  * 即上文的链接方法
* 显式调用（动态调用）：手动调用动态链接库中包含的资源，同时用完后要手动将资源释放
  * 显式调用动态链接库，更常应用于一些大型项目中
  * 显式调用动态链接库的过程，类似于使用 malloc() 和 free()（C++ 中使用 new 和 delete）管理动态内存空间
  * 需要时就申请，不需要时就将占用的资源释放。由此可见，显式调用动态链接库对内存的使用更加合理。

和隐式调用动态链接库不同，在 C/C++ 程序中显示调用动态链接库时，无需引入和动态链接库相关的头文件  
但与此同时，程序中需要引入另一个头文件，即` <dlfcn.h>` 头文件，因为要显式调用动态链接库，需要使用该头文件提供的一些函数。

`#include <dlfcn.h>`   相关笔记写在 cbasic.md 文档

这里需要添加 -ldl 选项（使用了 dlfcn.h后 , 该可执行程序需要 libdl.so 动态库的支持）
`gcc main.c -ldl -o main.exe`  

### 1.4.4. 解决找不到库的问题

1. 链接时 
   假设当前 mian.c 文件需要借助 libmymath.a 才能完成链接，则完成链接操作的 gcc 指令有以下 2 种写法
   * `gcc -static main.c libmymath.a -o main.exe`  
     GCC 编译器只会在当前目录中（这里为 demo 目录）查找 libmymath.a
   * `gcc -static main.c -lmymath -o main.exe`  
     GCC 编译器会按照如下顺序，依次到指定目录中查找所需库文件
     1. 如果 gcc 指令使用 -L 选项指定了查找路径，则 GCC 编译器会优先选择去该路径下查找所需要的库文件
     2. 再到 Linux 系统中 LIBRARY_PATH 环境变量指定的路径中搜索需要的库文件
     3. 最后到 GCC 编译器默认的搜索路径（比如 /lib、/lib64、/usr/lib、/usr/lib64、/usr/local/lib、/usr/local/lib64 等，不同系统环境略有差异）中查找
   根据使用的方法不同移动相关的链接库位置解决问题

2. 运行时
   执行已生成的可执行文件时，如果 GCC 编译器提示找不到所需的库文件，这意味着 GCC 编译器无法找到支持可执行文件运行的某些动态库文件  
   GCC 编译器提供有 ldd 指令，借助该指令，我们可以明确知道某个可执行文件需要哪些动态库文件做支撑、这些动态库文件是否已经找到、各个动态库文件的具体存储路径等信息

   当 GCC 编译器运行可执行文件时，会按照如下的路径顺序搜索所需的动态库文件
   1. 如果在生成可执行文件时，用户使用了-Wl,-rpath=dir（其中 dir 表示要查找的具体路径，如果查找路径有多个，中间用 : 冒号分隔）选项指定动态库的搜索路径，则运行该文件时 GCC 会首先到指定的路径中查找所需的库文件；
   2. GCC 编译器会前往 LD_LIBRARY_PATH 环境变量指明的路径中查找所需的动态库文件
   3. GCC 编译器会前往 /ect/ld.so.conf 文件中指定的搜索路径查找动态库文件
   4. GCC 编译器会前往默认的搜索路径中（例如 /lib、/lib64、/usr/lib、/usr/lib64 等）中查找所需的动态库文件。
   
   注意!! 可执行文件的当前存储路径，并不在默认的搜索路径范围内，因此即便将动态库文件和可执行文件放在同一目录下，GCC 编译器也可能提示“找不到动态库”

   
   * 将动态库文件的存储路径，添加到 LD_LIBRARY_PATH 环境变量中。假设动态库文件存储在 /usr 目录中，通知执行export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr指令，即可实现此目的（此方式仅在当前命令行窗口中有效）；
   * 修改动态库文件的存储路径，即将其移动至 GCC 编译器默认的搜索路径中。
   * 修改~/.bashrc 或 ~/.bash_profile 文件，即在文件最后一行添加export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:xxx（xxx 为动态库文件的绝对存储路径）。保存之后，执行 source .bashrc 指令（此方式仅对当前登陆用户有效）。

## 1.5. 编译标准

不同版本的 GCC 编译器，**默认使用**的标准版本也不尽相同。  

对于编译 C、C++ 程序来说，借助 `-std` 选项即可手动控制 GCC 编译程序时所使用的编译标准  

```
gcc/g++ -std=编译标准
```


# 2. gdb 调试

要想使用完整gdb功能, 需要在编译的时候保存调试信息  
`g++ -g -o hello hello.cpp `


在命令行输入 `gdb` 可以直接进入程序  
`(gdb)` 开头的命令行交互  


基础命令：  
| **命令        | 解释                                               | 示例             |
| ------------- | -------------------------------------------------- | ---------------- |
| file <文件名> | 加载被调试的可执行程序文件                         | (gdb) file hello |
| r             | Run的简写，从头运行被调试的程序, 停在第一个断点    | (gdb) r          |
| c             | Continue的简写，从断点继续                         | (gdb) c          |
| q             | Quit的简写，退出GDB调试环境。                      | (gdb) q          |
| i             | info的简写，用于显示各类信息，详情请查阅“help i”。 | (gdb) i          |


断点设置与调试
* b <行号> b <函数名称> b <函数名称> b <代码地址>
  * b: Breakpoint的简写，设置断点。两可以使用“行号”“函数名称”“执行地址”等方式指定断点位置。 其中在函数名称前面加“*”符号表示将断点设置在“由编译器生成的prolog代码处”。如果不了解汇编，可以不予理会此用法。
  * (gdb) b 8 (gdb) b main (gdb) b *main (gdb) b *0x804835c 
* d [编号]
  * d: Delete breakpoint的简写，删除指定编号的某个断点，或删除所有断点。断点编号从1开始递增。                             
  * (gdb) d 
* s           
  * 执行一行源程序代码，如果此行代码中有函数调用，则进入该函数
  * s 相当于其它调试器中的“Step Into (单步跟踪进入)”
  * s 与 n 命令必须在有源代码调试信息的情况下才可以使用（GCC编译时使用“-g”参数）
  * (gdb) s
* n
  * 执行一行源程序代码，此行代码中的函数调用也一并执行。相当于其它调试器中的“Step Over (单步跟踪)”
  * (gdb) n 
* si, ni
  * si命令类似于s命令，ni命令类似于n命令。所不同的是，这两个命令（si/ni）所针对的是汇编指令
  * 而s/n针对的是源代码。
  * * (gdb) si (gdb) ni                            
* p <变量名称>Print的简写，显示指定变量（临时变量或全局变量）的值。
  * (gdb) p i 
  * (gdb) p nGlobalVar                           
* display … undisplay <编号>
  * 设置程序中断后欲显示的数据及其格式。 例如，如果希望每次程序中断后可以看到即将被执行的下一条汇编指令，可以使用命令 “display /i pc”其中pc 代表当前汇编指令，/i 表示以十六进行显示。当需要关心汇编代码时，此命令相当有用。 undispaly，取消先前的display设置，编号从1开始递增。
  * (gdb) display /i $pc (gdb) undisplay 1                 



## 2.1. 启动
```
$ gdb main.out -silent
```
选项`-silent`用于屏蔽 GDB 的前导信息，否则它会在屏幕上打印一堆免责条款  

## 2.2. 设置断点

在 GDB 中，设置断点的方法很多，包括在指定的内存地址处设置断点、在源代码的某一行设置断点，或者在某个函数的入口处设置断点  

```shell
#用内存地址的方式来设置这个断点
# 星号*意味着是以内存地址作为断点的。
b * 0x4004f4

#如果用源代码行的形式设置这个断点，则可以是
b 5
```

## 2.3. 运行

一旦设置了断点，下一步就是用`r`或者`run`命令执行被调试的程序，执行后会自动在第一个断点处停下来： 
```
[New Thread 1500.0x1e34]
[New Thread 1500.0x2fb8]
Thread 1 hit Breakpoint 1, main () at main.c:5
5     n = 1;
```
在内容的最后会显示下一条执行的语句以及内容  

## 2.4. 打印变量
```
(gdb) p n
$1 = 24
(gdb) p sum
$2 = 140737488347344
```
GDB 先计算表达式的值，并把它保存在一个存储区中，存储区的名字用$外加数字来表  

