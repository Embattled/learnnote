# 1. 各种杂碎知识点
c++对默认参数, 只需要在声明或者实现部分任意一处设定即可, 不能两处都设定  
除法要想保留小数, 必须是用浮点数相除, 若是两个操作数都为整型, 结果会自动抹去小数  


## 1.1. 关于空指针  
nullptr是C++11版本中新加入的，它的出现是为了解决NULL表示空指针在C++中具有二义性的问题  

C++中关于空指针的定义  
```c++
int *p1 = NULL; // 需要引入cstdlib头文件
int *p2 = 0;
int *p3 = nullptr;
```

1. 关于NULL的定义
   在C++中,NULL被直接定义成整数0  
   而在C中,NULL的定义为 `#define NULL ((void *)0)`,也就是说NULL实际上是一个void* 指针  
   造成这种差异的原因是为了照顾C++的函数重载  
```Cpp
void Func(char *);
void Func(int);

int main()
{
    //C语言没有重载, 是弱类型语言,因此可以允许void*进行隐式转换  
    //C++为了重载, 是强类型语言,因此不允许void*的隐式重载, 将NULL更改为了整数0  
    //而根据传统思维, NULL应该代表的是char* , 但是因为C++中NULL就是整数0, 所以实际执行的是int的函数
    Func(NULL);
}
```
2. nullptr的使用
   注意`nullptr`是在C++11中引入的  
   nullptr可以转化为任意的指针和布尔值, 但是不能转变为整数  
   

## 1.2. 关于delete[]  

`delete` 和 `delete []` 之间的区别
delete只释放指针指向地的内存, 对于基础类型`int/char/long/int*/struct`等没有`析构函数`的类型可以正常释放,可以用于一般数组  
`delete []`的特点是会对数组中的每个对象调用析构函数,而`delete`不会,因此对于对象数组, 最好使用`delete []`  
尽管不管使用`delete还是delete[]`那三个对象数组内存中都会被删除,但是重点就在于析构函数的调用上    

* 如果你的类使用了操作系统资源,单纯把类的对象从内存中删除是不妥当的,因为没有调用对象的析构函数会导致系统资源不被释放
* 如果是Socket则会造成Socket资源不被释放,最明显的就是端口号不被释放,系统最大的端口号是65535(216 _ 1,因为还有0),如果端口号被占用了,你就不能上网了
* 如果File资源不被释放,你就永远不能修改这个文件,甚至不能读这个文件(除非注销或重器系统)
* 如果线程不被释放,这它总在后台运行,浪费内存和CPU资源
* 这些资源的释放必须依靠这些类的析构函数。所以,在用这些类生成对象数组的时候,用delete[]来释放它们才是王道。

## 1.3. 关于main函数的参数的使用
关于  
`int argc, char const *argv[]`  
* argc是命令行总的参数个数  
* argv[]是argc个参数,其中第0个参数是程序的全名,以后的参数是用户输入的参数  
* main 的返回值为 `0` 代表程序正常退出; 非 `0` 代表不正常,在shell中视为假.

## 1.4. 关于各种 size_t size_type 

size_t不是容器概念。  
size_type是容器概念，没有容器不能使用。  

* size_type 如同 int 、float等 一样也是一种数据类型，不同之处在于size_type会适应机器，不同的机器size_type会有不同的长度；只要你使用了这个类型，就使得你的程序适合这个机器。与实际机器匹配
* size_type 是由`string`类类型和`vector`类类型定义的类型，用以保存任意string对象或vector对象的长度，可以保证足够大能够存储任意string对象的长度。标准库类型将size_type定义为`unsigned`类型 
* 本质上来说，是一个整型数。关键是由于机器的环境，它的长度有可能不同
  * string抽象意义是字符串， size()的抽象意义是字符串的尺寸， `string::size_type`抽象意义是尺寸单位类型 
  * string::size_type它在不同的机器上，长度是可以不同的，并非固定的长度。但只要你使用了这个类型，就使得你的程序适合这个机器。与实际机器匹配


* 其实size_t和size_type类似，size_t 类型定义在`cstddef`头文件中,该文件是C标准库的头文件`stddef.h`的C++版本.它是一个与机器相关的unsigned类型,其大小足以保证存储内存中对象的大小。
  