# 1. 快速入门

## 1.1. 开始使用  

* 当需要root权限时,需要使用`sudo`执行命令  
    使用 `sudo passwd root ` 给root账户设置密码  

    解锁Root账户 `sudo passwd --unlook root  `

    切换到root管理员 `su root 要输入密码     sudo su直接登录`

    进入高级设置 `sudo raspi-config` (树莓派)


## 1.2. 关机重启命令

shutdown 最为推荐
    命令名称：shutdown。
    英文原意：bring the system down。
    所在路径：/sbin/shutdown。
    执行权限：超级用户。
    功能描述：关机和重启
`# shutdown [选项] 时间 [警告信息]`  
* -c：取消已经执行的 shutdown 命令；
* -h：关机；
* -r：重启；
```shell
shutdown -r now  # 立即重启
shutdown -r +10  # 10分钟后重启
shutdown -r 05:30 # 指定时间重启 (该命令会占用前台终端)
shutdown -r 05:30 & # 指定后把命令放入后端, & 是后台的意思
shutdown -h now #立即关机

shutdown -c # 取消定时任务
```

其他命令
```shell
reboot # 重启

halt #关机
poweroff #关机

# init 是修改 Linux 运行级别的命令,也可以用于关机和重启。 
init 0 # 关机
init 6 # 重启
```

## 1.3. 最基础的命令

| 序号 | 命令 | 功能 |
| ---- | ---- | ---- ||
| ls            | list                 | 查看当前文件夹下的内容       |
| pwd           | print work directory | 查看当前所在文件夹           |
| cd[目录名]    | changge directory    | 切换文件夹                   |
| touch[文件名] | touch                | 如果文件不存在,新建文件      |
| mkdir[目录名] | make directory       | 创建目录                     |
| rm[文件名]    | remove               | 删除指定文件                 |
| clear         | clear                | 清屏                         |
| which         | which directory      | 查找某个命令的可执行文件位置 |


    输入 man [内容] 来打开指定内容的手册, f 键前进一页, b 键后退一页, q 键退出
    ctrl + shift + = 放大终端窗口的字体显示
    ctrl + - 缩小终端窗口的字体显示
    如果想要退出选择,并且不想执行当前选中的命令,可以按 ctrl + c


## 1.4. 终端的快捷键

终端有很多快捷键,不太好记  

| 快捷键 | 功能                                                   |
| ------ | ------------------------------------------------------ |
| Ctrl+r | 实现快速检索使用过的历史命令。Ctrl+r中r是retrieve中r。 |
| Ctrl+a | 光标回到命令行首。 （a：ahead）                        |
| Ctrl+e | 光标回到命令行尾。 （e：end）                          |
| ctrl+w | 移除光标前的一个单词                                   |
| Ctrl+k | 删除光标处到行尾的字符。                               |
| Ctrl+u | 删除整个命令行文本字符。                               |
| Ctrl+y | 粘贴Ctrl+u,Ctrl+k,Ctrl+w删除的文本。                   |
| Ctrl+d | 删除提示符后一个字符或exit或logout                     |
| ctrl+t | 交换光标位置前后的两个字符                             |
| ctrl+y | 粘贴或者恢复上次的删                                   |
| Esc+b  | 移动到当前单词的开头                                   |
| Esc+f  | 移动到当前单词的结尾                                   |
| Esc+t  | 颠倒光标所在处及其相邻单词的位置                       |
| esc+.  | 上一个命令的后面的参数                                 |

ESC+c: 使下一个单词首  字母变大写, 同时光标前进一个单词, 如光标停留在单词的某个字母上, 如word中的o字母上, 则o字母变大写. 而不是w   
ESC+u: 使下一个单词所有字母变大写, 同时光标前进一个单词, 同上, 如光标在o字母上, 则ord变大写, w不变.  
ESC+l:同ESC-U, 但使之全变为小写  

## 1.5. 系统查看

Linux查看系统信息的一些命令

### 1.5.1. cat 系统信息文件打印

好多信息可以通过 cat 打印某一个文件来显示  

```shell
# 查看CPU信息
$ cat /proc/cpuinfo      

# 查看系统负载
$ cat /proc/loadavg      

# 查看内核/操作系统/CPU信息
$ cat /proc/version 

# 查看内存信息
$ cat /proc/meminfo

# 查看系统负载
$ cat /proc/loadavg      

# 打印发行版信息
$ cat /etc/issue

```
### 1.5.2. 查看系统版本命令

```shell

# 查看内核/操作系统/CPU信息
$ uname -a               

# 查看计算机名
$ hostname               


# 列出所有PCI设备  t 表示显示总线树 v 表示增加信息丰富度
$ lspci -tv              
# 列出所有USB设备
$ lsusb -tv              
# 列出加载的内核模块
$ lsmod                  
# 列出所有版本信息
$ lsb_release -a

# 查看环境变量
$ env                    

```
### 1.5.3. 查看资源和磁盘

```shell
# 查看资源

# 查看内存使用量和交换区使用量
$ free -m                

# 查看各分区使用情况
$ df -h                  

# 查看指定目录的大小
$ du -sh <目录名>        

# 查看系统运行时间、用户数、负载
$ uptime                 


# 查看磁盘和分区

# 查看挂接的分区状态
$ mount | column -t      

# 查看所有分区
$ fdisk -l               

# 查看所有交换分区
$ swapon -s              

# 查看磁盘参数(仅适用于IDE设备)
$ hdparm -i /dev/hda     

# 查看启动时IDE设备检测状况
$ dmesg | grep IDE       
```

## 1.6. linux 启动流程

Linux系统的启动过程并不复杂，其过程可以分为5个阶段：
1. 内核的引导
    当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。
    操作系统接管硬件以后，首先读入 `/boot` 目录下的内核文件 引导内核启动

2. 运行 init
    init 进程是系统所有进程的起点，可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。
    init进程的一大任务是 根据系统的运行级别`runlevel`去运行开机启动的程序。

3. 系统初始化
    在init的配置文件中有执行脚本的命令, 脚本主要是完成一些系统初始化的工作
    例 :激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务  

4. 建立终端 
    init接下来会打开6个终端，以便用户登录系统
    以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面
5. 用户登录系统
    一般来说，用户的登录方式有三种, 命令行登录, ssh登录, 图形界面登录

    Linux预设提供了六个命令窗口终端机让我们来登录。
    默认我们登录的就是第一个窗口，也就是tty1，这个六个窗口分别为tty1,tty2 … tty6，可以按下`Ctrl + Alt + F1 ~ F6` 来切换它们
    如果你安装了图形界面，默认情况下是进入图形界面的，此时你就可以按Ctrl + Alt + F1 ~ F6来进入其中一个命令窗口界面。

当你进入命令窗口界面后再返回图形界面只要按下Ctrl + Alt + F7 就回来了。


**运行级别runlevel**  linux一般有7个运行级别  
    运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
    运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
    运行级别2：多用户状态(没有NFS)
    运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式
    运行级别4：系统未使用，保留
    运行级别5：X11控制台，登陆后进入图形GUI模式
    运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动




# 2. Linux 工作管理

工作管理指的是在单个登录终端（也就是登录的 Shell 界面）同时管理多个工作的行为.  
把命令放入后台,然后把命令恢复到前台,或者让命令恢复到后台执行,这些管理操作就是工作管理。  

后台管理有几个事项：
1. 前台是指当前可以操控和执行命令的这个操作环境；后台是指工作可以自行运行,但是不能直接用 `Ctrl+C` 快捷键来中止它,只能使用 `fg/bg` 来调用工作。
2. 当前的登录终端只能管理当前终端的工作,而不能管理其他登录终端的工作。比如 tty1 登录的终端是不能管理 tty2 终端中的工作的。
3. 放入后台的命令必须可以持续运行一段时间,这样我们才能捕捉和操作它。
4. 放入后台执行的命令不能和前台用户有交互或需要前台输入,否则只能放入后台暂停,而不能执行。
   1. 比如 vi 命令只能放入后台暂停,而不能执行,因为 vi 命令需要前台输入信息；
   2. top 命令也不能放入后台执行,而只能放入后台暂停,因为 top 命令需要和前台交互。

## 2.1. jobs 工作查看命令

| 选项           | 含义                                   |
| -------------- | -------------------------------------- |
| -l（L 的小写） | 列出进程的 PID 号。                    |
| -n             | 只列出上次发出通知后改变了状态的进程。 |
| -p             | 只列出进程的 PID 号。                  |
| -r             | 只列出运行中的进程。                   |
| -s             | 只列出已停止的进程。                   |

```
[1]- 2023 Stopped top
[2]+ 2034 Stopped tar -zcf etc.tar.gz /etc
```

* 1 2     : 工作号
* 2023    : PID
* `-+`    : 最后一个放入后台的工作是 `+` , 倒数第二个放入后台的是 `-` , 再往前就没有标志了
* Stopped : 工作已暂停

## 2.2. 恢复前台  fg

`fg %[工作号]`  
* 如果不带工作号和`%`  则恢复的是带 `+` 号的进程  


## 2.3. 存入终端后台

1.  `命令 &`  在命令后 加入一个 `空格` 然后 `&`  直接将命令放入后台执行
2.  按键  `Ctrl+Z `  就算不和前台有交互，能在后台执行，也处于暂停状态，因为 Ctrl+Z 快捷键就是暂停的快捷键
    * 暂停存入后台后可以使用 `bg %[工作号]` 命令让该进程恢复后台运行
    * 和 `fg` 一样, 省略参数的时候默认恢复 `+` 号进程运行

这里的后台，其实指的是当前登陆终端的后台。  
当我们以远程管理服务器的方式，在远程终端执行后台命令，如果在命令尚未执行完毕时就退出登陆， 此命令的执行会被中断  


  
## 2.4. 存入系统后台  nohup 

在执行命令时, 在命令前加上 `nohup` 让后台工作在离开操作终端时，也能够正确地在后台执行  

`nohup [命令] &`  
`&` 表示此命令会立即终端后台工作 如果没有 `&` 则执行后此命令会在终端前台执行  



# 3. Linux 的进程管理

在 Linux 系统中,每个进程都有一个唯一的进程号（PID）  
启动一个进程主要有 2 种途径
* 通过手工启动
* 通过调度启动(事先进行设置,根据用户要求,进程可以自行启动)

对进程来说,每一个从终端开始运行的进程都会依附于这个终端,这个终端就称为这些进程的控制终端,当控制终端被关闭时,相应的进程都会自动关闭。

## 3.1. 手工启动
指的是由用户输入命令直接启动一个进程, 可以细分为前台启动和后台启动 2 种方式
* 当用户输入一个命令并运行,就已经启动了一个进程,而且是一个前台的进程
  * 假如启动一个比较耗时的进程,可以把该进程挂起(放入后台并暂停运行)
* 后台启动进程,其实就是在命令结尾处添加一个 `&`符号（注意,`&` 前面有空格）
  * 该进程非常耗时,且用户也不急着需要其运行结果的时候
  * 输入命令并运行之后,Shell 会提供给我们一个数字,此数字就是该进程的进程号

## 3.2. daemon进程 守护进程

1. 守护进程（Daemon Process）,也就是通常说的 Daemon 进程（精灵进程）,是 Linux 中的后台服务进程。
2. 是一个生存期较长的进程,通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。
3. 是个特殊的孤儿进程,为了避免进程被任何终端所产生的信息所打断,其在执行过程中的信息也不在任何终端上显示。

大多数Linux的服务器的服务都是守护进程, 特点:
1. 守护进程基本上都是以超级用户启动（ UID 为 0 ）
2. 没有控制终端（ TTY 为 ？）
3. 终端进程组 ID 为 -1 （ TPGID 表示终端进程组 ID）

## 3.3. ps 命令打印全部进程

在不同的 Linux 发行版上,ps 命令的语法各不相同  
为此,Linux 采取了一个折中的方法,即融合各种不同的风格,兼顾那些已经习惯了其它系统上使用 ps  命令的用户。  

过于复杂 , 几个基础命令如下
```shell
# a  显示一个终端的所有进程
# u  显示进程的归属用户及内存的使用情况
# x  显示没有控制终端的进程
# j  表示列出与作业控制相关的信息
ps aux # 可以查看系统中的所有进程
ps axj # 查看 daemon 进程

# -l 长格式显示进程的详细信息
# -e 显示所有进程
ps -le #查看系统中的所有进程, 能看到进程的父进程PID和进程优先级
ps -l  #只能看到当前SHELL产生的进程

```
ps aux 命令的输出含义:  
| 表头    | 含义                      |
| ------- | ------------------------- |
| USER    | 进程是哪个用户常见的      |
| %CPU    | 该进程占用CPU资源的百分比 |
| %MEM    | 同理, 占内存的百分比      |
| VSZ     | 占用虚拟内存的大小(KB)    |
| RSS     | 占用实际内存的大小(KB)    |
| TTY     | 表示该进程运行在哪个终端  |
| STAT    | 进程状态                  |
| START   | 进程的启动时间            |
| TIME    | 进程占用CPU的运算时间     |
| COMMAND | 产生该进程的命令名        |
STAT的状态:
  * -D: 不可被唤醒的睡眠状态, 通常用于 I/O 情况
  * -R: 正在运行
  * -S: 处于睡眠状态, 可以被唤醒
  * -s: 该进程包含紫禁城
  * -T: 停止状态, 后台挂起或者处于除错状态
  * -Z: 僵尸进程, 进程已经终止, 但是部分程序还留在内存中
  * -<: 高优先级
  * -N: 低优先级
  * -L: 被缩入内存
  * -l: 多线程(小写L)
  * -+: 表示该进程正位于后台


ps -le 命令输出信息
| 表头  | 含义                                                        |
| ----- | ----------------------------------------------------------- |
| F     | 进程的权限 1:进程可以被复制,到那时不能被执行 4:超级用户权限 |
| S     | 进程的状态, 同 aux 的 STAT                                  |
| UID   | 运行该进程的用户的IF                                        |
| PPID  | 父进程的ID                                                  |
| C     | CPU使用率(%)                                                |
| PRI   | 优先级,数值越小优先级越高                                   |
| NI    | 优先级, 数值越小优先级越高                                  |
| ADDR  | 进程在内存的哪个位置                                        |
| SZ    | 占用内存的大小                                              |
| WCHAN | 该进程是否正在运行 , `-` 表示正在运行                       |
| TTY   | 指明产生终端                                                |
| TIME  | 占用CPU运算时间                                             |
| CMD   | 同 aux 的 COMMAND                                           |

Linux的终端控制
* 本地终端
  * tty1 ~ tty7 代表本地控制台终端
  * 可以通过 Alt+ F1 ~ F7 快捷键切换不同的终端
  * tty1~tty6 是本地的字符界面终端,tty7 是图形终端
* 虚拟终端 , 一般是远程链接的终端 , 第一个链接占用 pts/0 第二个用 pts/1

## 3.4. top 动态持续监听进程

```shell
# 命令格式
$ top [选项]
```
选项:
* -d:             执行刷新秒数 默认是3秒
* -p 进程的pid:   只监听指定ID的进程
* -u 用户名:      之间听某个用户的进程
* -b:             使用批处理模式输出, 和 -n 选项合用将输出重定向到文件
* -n:             指定执行次数
* -s:             安全模式,避免在交互中出现错误

如果在操作终端执行 top 命令,则并不能看到系统中所有的进程,默认看到的只是 CPU 占比靠前的进程。  
如果我们想要看到所有的进程,则可以把 top 命令的执行结果重定向到文件中。  
不过 top 命令是持续运行的,这时就需要使用 "-b" 和 "-n" 选项了。  
` top -b -n 1 > /root/top.log`  

进入top命令后, 会进入交互式界面, 交互操作:  
| 操作   | 功能                                                             |
| ------ | ---------------------------------------------------------------- |
| ?或者h | 显示帮助                                                         |
| P      | 按照CPU使用率排序                                                |
| M      | 按照内存使用率排序                                               |
| N      | 按照PID排序                                                      |
| T      | 按照 TIME 即CPU累计运算时间排序                                  |
| k      | 按照pid给予某一个进程一个信号, 一般用于中止进程, 信号9是强制中止 |
| r      | 按照pid给与某个进程重设优先级 (NIce)值                           |
| q      | 退出                                                             |

重要的输出信息:
* load average : 系统在之前 1 分钟、5 分钟、15 分钟的平均负载, 一般认为不应该超过服务器 CPU 的核数
* id : 空闲 CPU 占用的 CPU 百分比
* 证明系统处于高负债的情况
  * 如果 1 分钟、5 分钟、15 分钟的平均负载高于 1
  * 如果 CPU 的使用率过高或空闲率过低
  * 物理内存的空闲内存过小
缓存（cache）是用来加速数据从硬盘中"读取"的,而缓冲（buffer）是用来加速数据"写入"硬盘的。  

同理 , top的输出表如下
| 表头    | 信息                                   |
| ------- | -------------------------------------- |
| PID     | 进程的 ID。                            |
| USER    | 该进程所属的用户。                     |
| PR      | 优先级,数值越小优先级越高。            |
| NI      | 优先级,数值越小、优先级越高。          |
| VIRT    | 该进程使用的虚拟内存的大小,单位为 KB。 |
| `RES`   | 该进程使用的物理内存的大小,单位为 KB。 |
| `SHR`   | 共享内存大小,单位为 KB。               |
| S       | 进程状态。                             |
| %CPU    | 该进程占用 CPU 的百分比。              |
| %MEM    | 该进程占用内存的百分比。               |
| TIME+   | 该进程共占用的 CPU 时间。              |
| COMMAND | 进程的命令名。                         |

## 3.5. pstree  查看进程树

pstree 命令是以树形结构显示程序和进程之间的关系  

`# pstree [选项] [PID或用户名]`  
| 选项 | 含义                                                        |
| ---- | ----------------------------------------------------------- |
| -a   | 显示启动每个进程对应的完整指令,包括启动进程的路径、参数等。 |
| -c   | 不使用精简法显示进程信息,即显示的进程中包含子进程和父进程。 |
| -n   | 根据进程 PID 号来排序输出,默认是以程序名排序输出的。        |
| -p   | 显示进程的 PID。                                            |
| -u   | 显示进程对应的用户名称。                                    |


如果不指定进程的 PID 号,也不指定用户名称,则会以 init 进程为根进程,显示系统中所有程序和进程的信息  
`init` 进程是系统启动的第一个进程,进程的 PID 是 1,也是系统中所有进程的父进程。  

如果想知道某个用户都启动了哪些进程,使用 pstree 命令可以很容易实现,以 mysql 用户为例  
`# pstree mysql`  

##  3.6. lsof 列出进程正在调用或者打开的文件
`list opened files`的缩写   


# 4. Linux 的服务管理

Linux 服务管理两种方式service和systemctl 

systemd是Linux系统**最新的初始化系统**(init),作用是提高系统的启动速度,尽可能启动较少的进程,尽可能更多进程并发启动。

systemd对应的进程管理命令就是 `systemctl`

## 4.1. service  

service命令其实是去`/etc/init.d`目录下,去执行相关程序, 已经被淘汰

```shell
# service命令启动redis脚本
service redis start
# 直接启动redis脚本
/etc/init.d/redis start
# 开机自启动
update-rc.d redis defaults
```

## 4.2. systemctl

### 4.2.1. 概念

systemctl命令兼容了service  

即systemctl也会去`/etc/init.d`目录下,查看,执行相关程序  

```shell
# 开机自启动某个服务
systemctl enable redis
```

通过 `Unit` 作为单位管理进程

`/usr/lib/systemd/system(Centos)`  
`/etc/systemd/system(Ubuntu)`  

systemd 默认读取 `/etc/systemd/system `下的配置文件,该目录下的文件会链接/lib/systemd/system/下的文件。执行 ls /lib/systemd/system 你可以看到有很多启动脚本,其中就有最初用来定义开机脚本的 `rc.local.service`

主要有四种类型文件.mount,.service,.target,.wants  
代表四种`Unit`  


### 4.2.2. 命令综述

`systemctl –-version`  查看版本  

systemctl 提供了子命令可以查看系统上的 unit,命令格式为:   

`systemctl [command] [unit]` 命令格式  
`systemctl [command] [--type=TYPE] [--all]` 

1. 不带任何参数执行 `systemctl` 命令会列出所有已启动的 unit  
   等同于`systemctl list-units`  
2. 如果添加 `-all` 选项会同时列出没有启动的 unit。    
3. `systemctl list-unit-files`: 根据 /lib/systemd/system/ 目录内的文件列出所有的 unit
   即列出所有已安装的服务    
4. `systemd-cgls`  以树形列出正在运行的进程,它可以递归显示控制组内容


**--type=TYPE**  
可以在综合查看unit时只指定某个类型的 unit。  
` systemctl list-units --type=service ` 

| 命令      | 功能简述                                                                  |
| --------- | ------------------------------------------------------------------------- |
| start     | 立刻启动后面接的 unit。                                                   |
| stop      | 立刻关闭后面接的 unit。                                                   |
| restart   | 立刻关闭后启动后面接的 unit,亦即执行 stop 再 start 的意思。               |
| reload    | 不关闭 unit 的情况下,重新载入配置文件,让设置生效。                        |
| enable    | 设置下次开机时,后面接的 unit 会被启动。                                   |
| disable   | 设置下次开机时,后面接的 unit 不会被启动。                                 |
| show      | 列出 unit 的配置。                                                        |
| status    | 目前后面接的这个 unit 的状态,会列出有没有正在执行、开机时是否启动等信息。 |
| is-active | 目前有没有正在运行中。                                                    |
| is-enable | 开机时有没有默认要启用这个 unit。                                         |
| kill      | 不要被 kill 这个名字吓着了,它其实是向运行 unit 的进程发送信号。           |
| mask      | 注销 unit,注销后你就无法启动这个 unit 了。                                |
| unmask    | 取消对 unit 的注销。                                                      |

### 4.2.3. status 命令

执行 `systemctl status [unit]`   

* 第一行是对 unit 的基本描述。  
* 第二行中的 Loaded 描述操作系统启动时会不会启动这个服务,enabled 表示开机时启动,disabled 表示开机时不启动。  
  * 关于 unit 的启动状态,除了 enable 和 disable 之外还有:  
  *   static:这个 unit 不可以自己启动,不过可能会被其它的 enabled 的服务来唤醒。
  * mask:这个 unit 无论如何都无法被启动！因为已经被强制注销。可通过 systemctl unmask 改回原来的状态。
* 第三行 中的 Active 描述服务当前的状态,active (running) 表示服务正在运行中。如果是 inactive (dead) 则表示服务当前没有运行。 
  * active (exited)：仅执行一次就正常结束的服务,目前并没有任何程序在系统中执行。
  * active (waiting)：正在执行当中,不过还再等待其他的事件才能继续处理。 
* 第四行的 Docs 提供了在线文档的地址。  

### 4.2.4. 操作环境管理
通过指定 `--type=target` 就可以用 `systemctl list-units` 命令查看系统中默认有多少种 target

| 操作环境          | 功能                                                                                                                                 |
| ----------------- | ------------------------------------------------------------------------------------------------------------------------------------ |
| graphical.target  | 就是文字界面再加上图形界面,这个 target 已经包含了下面的 multi-user.target。                                                          |
| multi-user.target | 纯文本模式！                                                                                                                         |
| rescue.target     | 在无法使用 root 登陆的情况下,systemd 在开机时会多加一个额外的临时系统,与你原本的系统无关。这时你可以取得 root 的权限来维护你的系统。 |
| emergency.target  | 紧急处理系统的错误,在无法使用 rescue.target 时,可以尝试使用这种模式！                                                                |
| shutdown.target   | 就是执行关机。                                                                                                                       |
| getty.target      | 可以设置 tty 的配置。                                                                                                                |

正常的模式是` multi-user.target `和 `graphical.target `两个,救援方面的模式主要是 `rescue.target` 以及更严重的 `emergency.target`。如果要修改可提供登陆的 tty 数量,则修改 getty.target。


| 命令        | 功能                                     |
| ----------- | ---------------------------------------- |
| get-default | 取得目前的 target。                      |
| set-default | 设置后面接的 target 成为默认的操作模式。 |
| isolate     | 切换到后面接的模式。                     |

我们还可以在不重新启动的情况下切换不同的 target,比如从图形界面切换到纯文本的模式：
`systemctl isolate multi-user.target`

## 4.3. Unit的编写与设置

### 4.3.1. Unit的基本概念
一般都会有  
Unit小节: 描述,启动时间与条件等等  

### 4.3.2. .service

.service文件定义了一个服务,分为[Unit],[Service],[Install]三个小节

`[Unit]` 段: 启动顺序与依赖关系   
`[Service] `段: 启动行为,如何启动,启动类型  
`[Install]` 段: 定义如何安装这个配置文件,即怎样做到开机启动  
### 4.3.3. .mounnt

.mount文件定义了一个挂载点,[Mount]节点里配置了What(名称),Where(位置),Type(类型)三个数据项

```
What=hugetlbfs
Where=/dev/hugepages
Type=hugetlbfs
```
等于执行以下命令  
`mount -t hugetlbfs /dev/hugepages hugetlbfs`  

### 4.3.4. .target

.target定义了一些基础的组件,供.service文件调用

### 4.3.5. .wants文件

`.wants`文件定义了要执行的文件集合,每次执行,`.wants`文件夹里面的文件都会执行  

### 4.3.6. 编写开机启动rc.local

查看`/lib/systemd/system/rc-local.server`,默认会缺少`Install`段,显然这样配置是无效的  

```shell
# rc.local.server的Unit段, 可以看到会执行 /etc/rc.local
[Unit]
Description=/etc/rc.local Compatibility
Documentation=man:systemd-rc-local-generator(8)
ConditionFileIsExecutable=/etc/rc.local
After=network.target


#修改文件进行配置  
[Install]  
WantedBy=multi-user.target  


#之后再在/etc/目录下面创建rc.local文件,赋予执行权限

$ touch /etc/rc.local
$ chmod +x /etc/rc.local

# 在rc.local里面写入
# 注意：'#!/bin/sh' 这一行一定要加

#!/bin/sh
exit 0

# 最后将/lib/systemd/system/rc.local.service 链接到/etc/systemd/system目录

$ ln -s /lib/systemd/system/rc.local.service /etc/systemd/system/
```

# 5. Linux 的文件和目录管理

## 5.1. Linux的目录详解

Linux 基金会的 FHS标准 制定了文件目录的标准  
`（Filesystem Hierarchy Standard）`  

规定了 Linux 系统中**所有**一级目录以及部分二级目录（/usr 和 /var）的用途  

### 5.1.1. 根目录 /

```shell

# 存放系统命令,所有用户都可以执行,包括单用户模式  
# 放置一些系统的必备执行档例如： cat、cp、chmod df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar等
/bin/

# 保存与系统环境设置相关的命令
# 主要放置一些系统管理的必备程式例如： cfdisk、dhcpcd、dump、e2fsck、fdisk、halt、ifconfig、ifup、 ifdown、init、insmod、lilo、lsmod、mke2fs、modprobe、quotacheck、reboot、rmmod、 runlevel、shutdown等
/sbin/


# 系统启动目录, 包括内核文件和启动引导程序 grub
/boot/

# 设备文件  
# ** 注意 /dev 下的文件是真实的设备 由UDEV在运行时创建
# udev 是Linux kernel 2.6系列的设备管理器。它主要的功能是管理/dev目录底下的设备节点
/dev/ 

# /sys/class 是由kernel在运行时导出的,目的是通过文件系统暴露出硬件的层级关系
/sys/class
# 使用示例 查看网络接口的名称
$ ls /sys/class/net


# 配置文件 服务的启动脚本  采用默认安装方式的服务配置文件在此之中 
/etc/

# 主目录
/home/

# *系统* 调用的函数库保存位置 
/lib/

# 虽然系统准备了三个默认挂载目录 /media/、/mnt/、/misc/,但是到底在哪个目录中挂载什么设备可以由管理员自己决定
# 挂载媒体设备, 如软盘和光盘
/media/
# 挂载目录, 如U盘,移动硬盘,*其他操作系统的分区*
/mnt/
# 挂载NFS服务的共享目录  
/misc/

# root用户的主目录,和用户的/home/123/类似
/root/

# 服务数据目录,保存服务启动后的数据
/srv/



```
### 5.1.2. 软件目录 /usr

注意不是 user, 全称为 `Unix Software Resource`  
FHS 建议所有开发者,应把软件产品的数据`合理的放置在 /usr 目录下的各子目录中`  
而不是为他们的产品创建单独的目录  
类似 Windows 系统中` C:\Windows\ + C:\Program files\` 两个目录的综合体

```shell
# 存放系统命令, 除了单用户以外的所有用户可以执行
# 主要放置一些应用软体工具的必备执行档例如： c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome*、 gzip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb*、wget等
/usr/bin/

# 同样是根文件系统不需要的系统管理命令,只有root可以执行
# 放置一些网路管理的必备程式例如： dhcpd、httpd、imap、in.*d、inetd、lpd、named、netconfig、nmbd、samba、sendmail、squid、swap、tcpd、tcpdump等
/usr/sbin/

# 应用程序调用的函数库位置
/usr/lib/

# 图形界面系统保存位置
/usr/XllR6/ 

#  手工安装的软件保存位置。我们一般建议源码包软件安装在这个位置
/usr/local/

# 应用程序的资源文件保存位置,如帮助文档、说明文档和字体目录
/usr/share/

# 我们手工下载的源码包和内核源码包都可以保存到这里
# 不过笔者更习惯把手工下载的源码包保存到 /usr/local/src/ 目录中
# 把内核源码保存到 /usr/src/linux/ 目录中
/usr/src/

# C/C++ 等编程语言头文件的放置目录
/usr/include/

```

### 5.1.3. /var 目录 

目录用于存储动态数据,例如缓存、日志文件、软件运行过程中产生的文件等  

## 5.2. 软硬链接文件 ln 命令


**ext4 文件系统**
1. 小部分用于保存文件的 inode (i 节点）信息,inode 的默认大小为 128 Byte
   1. 记录文件的权限（r、w、x）
   2. 文件的所有者和属组
   3. 文件的大小
   4. 文件的状态改变时间（ctime）
   5. 文件的最近一次读取时间（atime）
   6. 文件的最近一次修改时间（mtime）
   7. 文件的数据真正保存的 block 编号
   8. 每个文件需要占用一个 inode。
   9. inode 中是不记录文件名的，文件名记录在文件所在目录的 block 中。
2. 大部分用于保存 block 信息, 大小可以是 1KB、2KB、4KB，默认为 4KB
   1. 如果一个 block 放不下数据，则可以占用多个 block
   2. 有一个 10KB 的文件需要存储，则会占用 3 个 block
   3. 虽然最后一个 block 不能占满，但也不能再放入其他文件的数据
   4. 这 3 个 block 有可能是连续的，也有可能是分散的。
3. 目录的 block 中记录的是这个目录下所有一级子文件和子目录的文件名及 inode 的对应
4. 文件的 block 中记录的才是文件实际的数据


**ln 命令** 
1. 软链接: 也称作符号链接, 类似于 Windows 系统中给文件创建快捷方式，即产生一个特殊的文件，该文件用来指向另一个文件，此链接方式同样适用于目录
   1. 软链接的源文件必须写绝对路径，否则建立的软链接文件就会报错
   2. 权限位中"l"表示这是一个软链接文件；其次，在文件的后面通过 "->" 显示出源文件的完整名字
   3. 软链接可以链接目录，也可以跨分区来建立软链接
   4. 不论源文件还是软链接文件，数据都发生改变
   5. 删除软链接文件，源文件不受影响。而删除原文件，软链接文件将找不到实际的数据，从而显示文件不存在
2. 硬链接: 指的就是给一个文件的 inode 分配多个文件名，通过任何一个文件名，都可以找到此文件的 inode，从而读取该文件的数据信息
   1. 修改源文件（test 文件），还是修改硬链接文件（test-hard 文件），另一个文件中的数据都会发生改变
   2. 删除源文件，还是删除硬链接文件，只要还有一个文件存在，这个文件（inode 号是 262147 的文件）都可以被访问
   3. 硬链接不会建立新的 inode 信息，也不会更改 inode 的总数
   4. 硬链接不能跨文件系统（分区）建立，因为在不同的文件系统中，inode 号是重新计算的
   5. 硬链接不能链接目录，因为如果给目录建立硬链接，那么不仅目录本身需要重新建立，目录下所有的子文件，包括子目录中的所有子文件都需要建立硬链接，这对当前的 Linux 来讲过于复杂
   6. 硬链接的限制比较多，既不能跨文件系统，也不能链接目录，而且源文件和硬链接文件之间除 inode 号是一样的之外，没有其他明显的特征
   

```shell

ln [选项] 源文件 目标文件 

# -f：强制。如果目标文件已经存在，则删除目标文件后再建立链接文件；
# -s：建立软链接文件, 默认建立硬链接

touch cangls
ln /root/cangls /tmp


# 软链接文件的源文件必须写成绝对路径，而不能写成相对路径（硬链接没有这样的要求）
In -s /root/bols /tmp
```

## 5.3. 文件打包和压缩

* 归档 : 也称打包, 指的是不经过压缩的文件或目录的几何
* 压缩 : 使用了压缩算法

### 5.3.1. tar 命令

Linux中最常用的打包命令
* 使用 tar 命令归档的包成为 tar 包, 文件以 .tar 结尾
* `tar [选项] 源文件或目录`  可以同时打包多个文件或目录, 用空格分开名称
* 最常用的打包指令就是 `-cvf 输出名 输入文件`
* 最常用的解包指令是 `-xvf tar文件名 -C 输出目录`
* 如果需要在打包的同时进行压缩, 或者解压缩, 使用 压缩相关的专用命令
  * `-z` 对 .tar.gz 格式的文件进行解压缩或者压缩成该格式
  * `-j` 对 .tar.bz2 格式的文件进行解压缩或者压缩成该格式

打包命令表
| 选项    | 功能                                     |
| ------- | ---------------------------------------- |
| -c      | 多个文件或者目录进行打包                 |
| -A      | 追加 tar 文件到一个已归档的文件          |
| -f 包名 | 指定输出的文件名, 注意要指定正确的拓展名 |
| -v      | 显示打包过程                             |

解包命令表
| 选项    | 功能                                     |
| ------- | ---------------------------------------- |
| -x      | 对 tar 文件进行解包                      |
| -f 包名 | 指定要解包的包名                         |
| -t      | 不进行解包, 只输出包中的文件名和一级目录 |
| -C      | 指定解打包的位置                         |
| -v      | 显示打包过程                             |


### 5.3.2. zip 命令

zip是 windows 和 linux 通用的文件压缩方法, 属于主流之一
* zip 类型的压缩和解压缩的命令是分开的
* `zip [选项] 压缩包名 源文件或源目录列表`, 压缩命令要先输入输出文件名
* `unzip [选项] 压缩包名`

zip命令表
| 选项      | 含义                                                                |
| --------- | ------------------------------------------------------------------- |
| -r        | 递归压缩目录，及将制定目录下的所有文件以及子目录全部压缩。          |
| -m        | 将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中。          |
| -v        | 显示详细的压缩过程信息。                                            |
| -q        | 在压缩的时候不显示命令的执行过程。                                  |
| -压缩级别 | 压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好。 |
| -u        | 更新压缩文件，即往压缩文件中添加新文件。                            |


unzip命令表
| 选项          | 含义                                                       |
| ------------- | ---------------------------------------------------------- |
| -d 目录名     | 将压缩文件解压到指定目录下。                               |
| -n            | 解压时并不覆盖已经存在的文件。                             |
| -o            | 解压时覆盖已经存在的文件，并且无需用户确认。               |
| -v            | 不解压查看压缩文件的详细信息，文件大小、文件名以及压缩比等 |
| -t            | 测试压缩文件有无损坏，但并不解压。                         |
| -x 文件名列表 | 解压文件，但不包含文件列表中指定的文件。                   |



# 6. Linux 的用户管理

Linux 是多用户多任务操作系统，换句话说，Linux 系统支持多个用户在同一时间内登陆，不同用户可以执行不同的任务，并且互不影响。  
* 用户都有唯一的用户名和密码。在登录系统时，只有正确输入用户名和密码，才能进入系统和自己的主目录
* 用户组是具有相同特征用户的逻辑集合, 通过定义用户组，很多程序上简化了对用户的管理工作。 一个用户可以属于不同的多个组, 拥有所有组的各自权限


Linux 系统中，每个用户的 ID 细分为 2 种，分别是用户 ID（User ID，简称 UID）和组 ID Group ID，简称 GID

## 6.1. 相关文件

Linux 系统将所有用户的名称与 ID 的对应关系都存储在 `/etc/passwd`  

### 6.1.1. /etc/passwd

是系统用户配置文件，存储了系统中所有用户的基本信息，并且所有用户都可以对此文件执行读操作  

文件用户中的绝大多数是系统或服务正常运行所必需的用户，这种用户通常称为 `系统用户` 或 `伪用户`  
系统用户无法用来登录系统，但也不能删除，因为一旦删除，依赖这些用户运行的服务或程序就不能正常执行，会导致系统问题。  


信息格式, 每行用户信息都以 "：" 作为分隔符，划分为 7 个字段:   
`用户名：密码：UID（用户ID）：GID（初始组ID）：描述性信息：主目录：默认Shell`   
* 用户名 就是一串代表用户身份的字符串 和 UID GID 进行匹配
* 密码   "x" 表示此用户设有密码，但不是真正的密码，真正的密码保存在 `/etc/shadow`

**UID**
0             : 超级用户。UID 为 0 就代表这个账号是管理员账号  
1~499         : 系统用户（伪用户）。也就是说，此范围的 UID 保留给系统使用。其中，1~99 用于系统自行创建的账号；100~499 分配给有系统账号需求的用户。  
500~65535     : 普通用户   

**GID**
* 初始组      : 指用户登陆时就拥有这个用户组的相关权限。每个用户的初始组只能有一个  
* 附加组      : 指用户可以加入多个其他的用户组，并拥有这些组的权限  
初始组和附加组的身份是可以修改的，但是我们在工作中不修改初始组，只修改附加组，因为修改了初始组有时会让管理员逻辑混乱  


**描述性信息**  
这个字段并没有什么重要的用途，只是用来解释这个用户的意义而已  

**主目录**  
也就是用户登录后有操作权限的访问目录，通常称为用户的主目录。  

* root 超级管理员账户的主目录为 /root
* 普通用户的主目录为 /home/yourIDname

**默认的Shell**  
Shell 就是 Linux 的命令解释器，是用户和 Linux 内核之间沟通的桥梁  
* Linux 系统默认使用的命令解释器是 bash（/bin/bash）
* 可以理解为用户登录之后所拥有的权限
    * 默认: lamp:x:502:502::/home/lamp:**/bin/bash**
    * 禁止登陆 : lamp:x:502:502::/home/lamp:**/sbin/nologin**
    * 登录之后就只能修改自己的密码: lamp:x:502:502::/home/lamp:**/usr/bin/passwd**

### 6.1.2. /etc/shadow

由于/etc/passwd 允许所有用户读取，易导致用户密码泄露  
因此 Linux 系统将用户的密码信息从 /etc/passwd 文件中分离出来，并单独放到了此文件中  

* 文件只有 root 用户拥有读权限，其他用户没有任何权限
* 用于存储 Linux 系统中用户的密码信息

内容格式:  
`用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段`  


* 加密密码  : 加密后的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法
* 最后一次修改时间 : 以  1970 年 1 月 1 日作为 1 不断累加得到的时间
* 最小修改时间间隔 : 防止用户频繁更改账户密码 单位为天, 默认值为 0
* 密码有效期 : 强制要求用户变更密码, 单位为天, 默认值为 99999, 也就是 273 年, 可认为是永久生效
* 警告天数  : 默认值是 7
* 过期后的宽限天数 : 如果过了宽限天数，系统将不再让此账户登陆，也不会提示账户过期，是完全禁用
* 账号失效时间  : 通常被使用在具有收费服务的系统


**忘记密码的补救方法**
1. 普通账户的密码遗失，可以通过 root 账户解决, root用户可以 重新配置好指定账户的密码，而不需知道原有的密码
2. root 账号的密码遗失，则需要重新启动进入单用户模式
   1. 系统会提供 root 权限的 bash 接口, 此时可以用 passwd 命令修改账户密码
   2. 或者通过挂载根目录，修改 /etc/shadow，将账户的 root 密码清空的方法，此方式可使用 root 无法密码即可登陆


### 6.1.3. /etc/group

### 6.1.4. /etc/skel

在创建一个新用户后，你会发现，该用户主目录并不是空目录  
而是有 .bash_profile、.bashrc 等文件  
这些文件都是从 /etc/skel 目录中自动复制过来的。  
因此，更改 /etc/skel 目录下的内容就可以改变新建用户默认主目录中的配置文件信息  


## 6.2. 命令

### 6.2.1. useradd

使用 useradd 命令新建用户 `useradd [选项] 用户名`  
useradd 命令创建用户的过程，其实就是修改了与用户相关的几个文件或目录  

在没有特殊要求下，无需使用任何选项即可成功创建用户. 系统已经规定了非常多的默认值  

例如: `useradd lamp` 的执行步骤
1. 在 /etc/passwd 文件中创建一行与 lamp 用户相关的数据
2. 在 /etc/shadow 文件中新增了一行与 lamp 用户密码相关的数据
3. 在 /etc/group 文件中创建一行**与用户名一模一样的群组**作为新用户的初始组
4. 在 /etc/gshadow 文件中新增一行与新增群组相关的密码信息
5. 默认创建用户的主目录和邮箱
6. 将 /etc/skel 目录中的配置文件复制到新用户的主目录中

### 6.2.2. passwd



## 6.3. 文件权限

每个文件都有自己的拥有者 ID 和群组 ID，当显示文件属性时，系统会根据 `/etc/passwd` 和 `/etc/group` 文件中的内容，分别找到 UID 和 GID 对应的用户名和群组名，然后显示出来  
对任意一个文件（Linux下一切皆文件，包括目录、CPU内存等设备） 使用 `ls -l` 可以查看文件的类型和权限

输出: (d|-)rwxrwxrwx
* d表示目录,-表示普通文件,s套接字，l链接文件
* 9列，每3列一组，总共3组，对应文件属主(owner)、属主组员(group)和其他用户(other)对该文件的权限
* rwx。rwx是读(read)，写(write)和执行(execute)三种权限的缩写


* root用户是bug，电脑上所有的文件都是它的，权限位设置对其无效。
* 非root用户默认 只对 自己的 `home` 目录有完全的控制权限，对 `/tmp` 目录有读写的权限
* `/var、/usr、/bin、/opt` 等常见文件夹及子目录，几乎所有用户都能访问其中的文件和内容，执行可执行程序，但只有root用户和属主有写入的权限
* 

## 6.4. 软件安装

大部分软件默认安装路径是 `/usr/bin` 或 `/usr/local/bin`  
普通用户没有目录的写权限，于是提示无权限导致安装失败  



# 7. 环境配置  

## 7.1. 环境变量

可以使用env和echo命令来查看linux中的所有环境变量  
一个相同的环境变会因为用户身份的不同而具有不同的值  
`env`  
`echo $<环境变量名称>`  


| 环境变量名称 | 作用                                   |
| ------------ | -------------------------------------- |
| HOME         | 用户的主目录（也称家目录）             |
| SHELL        | 用户使用的 Shell 解释器名称            |
| PATH         | 定义命令行解释器搜索用户执行命令的路径 |
| EDITOR       | 用户默认的文本解释器                   |
| RANDOM       | 生成一个随机数字                       |
| LANG         | 系统语言、语系名称                     |
| HISTSIZE     | 输出的历史命令记录条数                 |
| HISTFILESIZE | 保存的历史命令记录条数                 |
| PS1          | Bash解释器的提示符                     |
| MAIL         | 邮件保存路径                           |

**创建一个环境变量**  
直接使用 `<名称>=<数值>`  
`WORKDIR=/home/work1`  

这种环境变量不具有全局性,作用范围也有限,可以使用`export` 将其提升到全局变量  
`export WORKDIR`  
`export WORKDIR=/home/work1`  
这种同样也只适用于当前shell , 关闭后即消失  


## 7.2. 环境信息配置文件

### 7.2.1. 交互式shell和非交互式shell的区别
首先要弄明白什么是交互式shell和非交互式shell , 即 `login shell` 和`non-login shell`

* 交互式模式就是shell等待你的输入,并且执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互。
* 非交互式模式下,shell不与你进行交互,而是读取存放在文件中的命令,并且执行它们。当它读到文件的结尾,shell也就终止了。
  
系统中存在许多bashrc和profile文件  
* bashrc与profile都用于保存用户的环境信息  
* bashrc用于交互式non-loginshell
* 而profile用于交互式login shell。

### 7.2.2. 文件分布

* `/etc/profile` 
  * 此文件为系统的**每个用户**设置环境信息 当第一个用户登录时,该文件被执行  
  * 并从`/etc/profile.d` 目录的配置文件中搜集shell的设置 
* `/etc/bashrc`
  * 为每一个运行bash shell的用户执行此文件
  * 当bash shell被打开时,该文件被读取
  * 有些linux版本中的/etc目录下已经没有了bashrc文件。
* `~/.profile`
  * 每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!
* `~/.bashrc`
  * 该文件包含专用于某个用户的bash shell的bash信息,当该用户登录时以及每次打开新的shell时,该文件被读取.

**总结**  
当登入系统时候获得一个shell进程时,其读取环境设定档有三步
1. 首先读入的是全局环境变量设定档`/etc/profile`,然后根据其内容读取额外的设定的文档,如`/etc/profile.d`和`/etc/inputrc`
2. 然后根据不同使用者帐号,去其家目录读取`~/.bash_profile`,如果这读取不了就读取`~/.bash_login`,这个也读取不了才会读取`~/.profile` ,这三个文档设定基本上是一样的,读取有优先关系
3. 然后在根据用户帐号读取`~/.bashrc`
   
至于~/.profile与~/.bashrc的不区别
1. 都具有个性化定制功能
2. `~/.profile`可以设定本用户专有的路径,环境变量,等,它只能登入的时候执行一次
3. `~/.bashrc` 也是某用户专有设定文档,可以设定路径,命令别名,每次shell script的执行都会使用它一次

# 8. 查找字符文件

## 8.1. 通配符
要注意通配符与正则表达式的区别  
简单的理解为通配符只有 `*,?,[],{}` 这4种, 而正则表达式复杂多了

| 通配符                | 含义                                        | 实例                                                                               |
| --------------------- | ------------------------------------------- | ---------------------------------------------------------------------------------- |
| *                     | 匹配 0 或多个字符                           | a*b a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab. |
| ?                     | 匹配任意一个字符                            | a?b a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b.            |
| [list]                | 匹配 list 中的任意单一字符                  | a[xyz]b  a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb.    |
| [c1-c2]               | 匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z] | a[0-9]b 0与9之间必须也只能有一个字符 如a0b, a1b... a9b.                            |
| [!list]或[^list]      | 匹配 除list 中的任意单一字符                | a[!0-9]b a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b.        |
| [!c1-c2]或[^c1-c2]    | 匹配不在c1-c2的任意字符                     | a[!0-9]b 如acb adb                                                                 |
| {string1,string2,...} | 匹配 sring1 或 string2 (或更多)其一字符串   | a{abc,xyz,123}b 列出aabcb,axyzb,a123b                                              |

## 8.2. 查找文件

    find 命令功能非常强大,通常用来在 特定的目录下 搜索 符合条件的文件  
`find [路径] -name "*.py"`  查找指定路径下扩展名是 .py 的文件,包括子目录

    
    如果省略路径,表示在当前文件夹下查找
    之前学习的通配符,在使用 find 命令时同时可用

## 8.3. 正则表达式

针对文件内容的文本过滤工具里,大都用到正则表达式,如vi,grep,awk,sed等  
其他的一些编程语言,如C++（c regex,c++ regex,boost regex）,java,python等都***有自己的正则表达式库***.

正则表达式的保留字符及意义, 若想使用他们需要在前面加上转义字符 `'\'`
| 字符 | 含义                          | 例                                                                  |
| ---- | ----------------------------- | ------------------------------------------------------------------- |
| ^    | 指向锚定行的开头              | '^grep'匹配所有以grep开头的行                                       |
| $    | 指向锚定行的结尾              | 'grep$'匹配所有以grep结尾的行                                       |
| .    | 任意非换行符的单个字符        | 'gr.p'匹配gr后接一个任意字符,然后是p                                |
| \*   | 匹配零个或多个先前字符        | '\*grep'匹配所有一个或多个空格后紧跟grep的行 `.*`一起用代表任意字符 |
| []   | 字符范围或者特殊匹配。如[a-z] | '[Gg]rep'匹配Grep和grep                                             |
| `\<` | 锚定单词的开始                | '\<grep'匹配包含以grep开头的单词的行                                |
| `\>` | 锚定单词的结束                | 'grep\>'匹配包含以grep结尾的单词的行。                              |

**特殊匹配表**
| 匹配模式   | 含义                                       | 匹配模式  | 含义         |
| ---------- | ------------------------------------------ | --------- | ------------ |
| [:alnum:]  | 字母与数字字符,如grep[[:alnum:]] words.txt | [:alpha:] | 字母         |
| [:ascii:]  | ASCII字符                                  | [:blank:] | 空格或制表符 |
| [:cntrl:]  | ASCII控制字符                              | [:digit:] | 数字         |
| [:graph:]  | 非控制、非空格字符                         | [:lower:] | 小写字母     |
| [:print:]  | 可打印字符                                 | [:punct:] | 标点符号字符 |
| [:space:]  | 空白字符,包括垂直制表符                    | [:upper:] | 大写字母     |
| [:xdigit:] | 十六进制数字                               |

**拓展匹配**

使用 `grep -E` 开启了拓展模式后可以使用更多的控制字符  
控制匹配完成的其他字符可能会遵循正则表达式的规则,对于grep命令,我们还需要在这些字符前面加上\,下表是扩展部分一览
| 选项  | 含义                        |
| ----- | --------------------------- |
| ?     | 最多一次                    |
| *     | 必须匹配0次或多次           |
| +     | 必须匹配1次或多次           |
| {n}   | 必须匹配n次                 |
| {n,}  | 必须匹配n次或以上           |
| {n,m} | 匹配次数在n到m之间,包括边界 |


### 8.3.1. 字符查找 grep

 `grep `(global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)  

`grep [OPTION]... PATTERNS [FILE]...`

**例子**   

    查找文件test中出现单词hi,并且若干字符后出现单词Jerry的行
    grep -E "\<hi\>.+\<Jerry\>" test


# 9. Shell基础  



## 9.1. source 命令 

source命令也称为“点命令”,也就是一个点符号（.）,是bash的内部命令。  
功能：使Shell读入指定的Shell程序文件并依次执行文件中的所有语句  
以下两种都是正确的使用  
`source filename `  
`. filename`（中间有空格）  

几种类似命令的区别  
| 命令            | 功能于区别                       |
| --------------- | -------------------------------- |
| source filename | 读取脚本在**当前**shell里执行    |
| sh filename     | 新建一个子shell,继承当前环境变量 |
| .filename       | 只是执行当前目录下的脚本         |



## 9.2. Ubuntu开机自动脚本

* Ubuntu18.04以后的版本 默认是没有 /etc/rc.local 这个文件的,需要自己创建  
* Ubuntu执行开机任务的流程
  * systemd 默认读取 `/etc/systemd/system `下的配置文件
  * 该目录下的文件会链接 `/lib/systemd/system/`下的文件
  * 执行 `ls /lib/systemd/system `你可以看到有很多启动脚本
  * 其中就有我们需要的 已经不默认启用的 rc.local.service  
* 查看rc.local.service文件内容

```shell
# This unit gets pulled automatically into multi-user.target by
# systemd-rc-local-generator if /etc/rc.local is executable.
[Unit]
Description=/etc/rc.local Compatibility
Documentation=man:systemd-rc-local-generator(8)
ConditionFileIsExecutable=/etc/rc.local
After=network.target

[Service]
Type=forking
ExecStart=/etc/rc.local start
TimeoutSec=0
RemainAfterExit=yes
GuessMainPID=no
```

剩下的内容在service.md里写了  


## 9.3. 脚本文件

### 9.3.1. 脚本文件格式

1. 脚本第一行必须写`#!/bin/sh`, shell脚本是用 `#` 来作为注释,但是对 `#!/bin/sh`不是
   *  `#!` 是一个特殊的表示符 指定了该脚本被执行的 shell的路径
   *  只能放在第一行
   *  如果没有声明，则脚本将在默认的shell中执行 

```shell
#!/bin/sh

```