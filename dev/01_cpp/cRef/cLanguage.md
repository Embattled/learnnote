- [1. C 语言](#1-c-语言)
  - [1.1. C语言的版本](#11-c语言的版本)
  - [1.2. C 语言的构成](#12-c-语言的构成)
- [Basic Concepts](#basic-concepts)
- [Keywords](#keywords)
- [2. Declaration 声明](#2-declaration-声明)
  - [2.1. 声明的根本构成](#21-声明的根本构成)
    - [2.1.1. specifiers-and-qualifiers 说明符和限定符](#211-specifiers-and-qualifiers-说明符和限定符)
    - [2.1.2. declarators-and-initializers 声明对象及初始化](#212-declarators-and-initializers-声明对象及初始化)
  - [2.2. Storage-class specifiers 存储级别 描述符](#22-storage-class-specifiers-存储级别-描述符)
  - [2.3. type qualifiers 类型限定符](#23-type-qualifiers-类型限定符)
    - [2.3.1. const](#231-const)
    - [2.3.2. volatile](#232-volatile)
    - [2.3.3. restrict](#233-restrict)
  - [2.4. Array declaration 数组的声明](#24-array-declaration-数组的声明)
- [3. Expressions C 表达式](#3-expressions-c-表达式)
  - [3.1. 一般概念](#31-一般概念)
    - [3.1.1. 运算符优先级](#311-运算符优先级)
    - [3.1.2. 值类型](#312-值类型)
  - [3.2. 运算符](#32-运算符)
    - [3.2.1. iso646.h](#321-iso646h)
    - [3.2.2. 特殊运算符](#322-特殊运算符)
  - [3.3. Constants and literals](#33-constants-and-literals)
    - [3.3.1. Integer constant](#331-integer-constant)
    - [3.3.2. Floating constant](#332-floating-constant)
- [4. C语言指针](#4-c语言指针)
  - [4.1. 野指针](#41-野指针)
  - [4.2. 指针的定义](#42-指针的定义)
    - [4.2.1. 数组指针 数组名](#421-数组指针-数组名)
    - [4.2.2. 数组和指针的可交换性 下标 \[\]](#422-数组和指针的可交换性-下标-)
    - [4.2.3. C语言字符串](#423-c语言字符串)
    - [4.2.4. 函数中的指针](#424-函数中的指针)
    - [4.2.5. NULL 指针](#425-null-指针)
    - [4.2.6. void 指针](#426-void-指针)
    - [4.2.7. 函数指针](#427-函数指针)
- [5. 预处理命令](#5-预处理命令)
  - [5.1. include](#51-include)
  - [5.2. define 宏定义](#52-define-宏定义)
    - [5.2.1. 带参数的宏定义](#521-带参数的宏定义)
    - [5.2.2. 特殊宏定义](#522-特殊宏定义)
  - [5.3. 条件宏](#53-条件宏)
    - [5.3.1. if](#531-if)
    - [5.3.2. ifdef](#532-ifdef)
  - [5.4. error 报错停止](#54-error-报错停止)
  - [5.5. 预定义宏](#55-预定义宏)
    - [5.5.1. 平台](#551-平台)
    - [5.5.2. 编译模式](#552-编译模式)
- [6. 多文件编程](#6-多文件编程)
  - [6.1. 从 extern 开始](#61-从-extern-开始)
  - [6.2. 防止重复包含头文件](#62-防止重复包含头文件)
  - [6.3. 命名空间](#63-命名空间)
  - [6.4. const 在多文件编程中](#64-const-在多文件编程中)
  - [6.5. 头文件应该写什么](#65-头文件应该写什么)
- [7. C语言和内存](#7-c语言和内存)
  - [7.1. 操作系统基础](#71-操作系统基础)
    - [7.1.1. 虚拟内存](#711-虚拟内存)
    - [7.1.2. 编译模式](#712-编译模式)
    - [7.1.3. 地址对齐](#713-地址对齐)
    - [7.1.4. 内存分页](#714-内存分页)
    - [7.1.5. MMU](#715-mmu)
  - [7.2. C语言的内存布局](#72-c语言的内存布局)
    - [7.2.1. 内核空间](#721-内核空间)
    - [7.2.2. Linux 的内存模型](#722-linux-的内存模型)
    - [7.2.3. Windows 的内存模型](#723-windows-的内存模型)
    - [7.2.4. 进程与内存](#724-进程与内存)
    - [7.2.5. 内核模式与用户模式](#725-内核模式与用户模式)
  - [7.3. 栈与进程 栈帧](#73-栈与进程-栈帧)
    - [7.3.1. 栈与函数 调用惯例](#731-栈与函数-调用惯例)
    - [7.3.2. 栈溢出的本质](#732-栈溢出的本质)
  - [7.4. 堆与进程 动态内存](#74-堆与进程-动态内存)
    - [7.4.1. 堆与内存池](#741-堆与内存池)
    - [7.4.2. 堆与内存泄漏 Memory Leak](#742-堆与内存泄漏-memory-leak)
- [8. C语言多线程](#8-c语言多线程)
  - [8.1. Linux POSIX 标准](#81-linux-posix-标准)
    - [8.1.1. C 语言下的编译](#811-c-语言下的编译)
    - [8.1.2. 线程操作](#812-线程操作)
    - [8.1.3. 4种线程同步方法](#813-4种线程同步方法)
    - [8.1.4. 线程属性](#814-线程属性)
  - [8.2. Windows 的POSIX](#82-windows-的posix)
  - [8.3. C++11 的多线程](#83-c11-的多线程)
- [9. dlfcn.h  显示调用动态链接库](#9-dlfcnh--显示调用动态链接库)

# 1. C 语言

区别于 C++ 独立的, 纯正的 C 语言原本的内容

所有内容基于 ANSI C (C89), 新版本的C标准 (C95及以上)用单独的章节独立标注

## 1.1. C语言的版本

**前身**:
* 1969 : B语言出现, 加入了 `++ --` 运算符, 无数据类型语言
* 1971 : NB (New B) 语言出现, 出现了 `int char arrays pointers`等类型
* 1972 : NB 重命名为 C, 加入了结构体, 预处理命令, 逻辑 `&& ||`, 还有便携 IO
* 1973 : Unix 重写了 C, 加入了 `unsigned long unions` 增加了类型的安全性
* 1978 : C 语言正式诞生

**标准C语言**
* 1983 : ANSI 建立了 `X3J11` 委员会用于制定 C 语言标准
* 1988 : C 语言 2nd 版本发布
* 1989 : ANSI 发布了第一个 C 语言标准 `C89 / ANSIC`, 
* 1990 : ANSI 将 C标准提交到 ISO, 被称为 `C90`
* 1995 : `C95` 加入了宽字符的支持 `wctype`
* 1999 : `C99` 加入 `bool longlong` 等新特性
* 2011 : `C11` 加入了线程意识的内存管理等新特性
* 2018 : `C17` 新特性


**总结**
1. C89/C90
   * 第一个C语言标准通常被称为 `ANSI C`。又由于这个版本是 89 年完成制定的, 因此也被称为 C89。
   * 后来 ANSI 把这个标准提交到 ISO（国际化标准组织）, 1990 年被 ISO 采纳为国际标准, 称为 `ISO C`。又因为这个版本是1990年发布的, 因此也被称为 C90。
   * 因为 ANSI 与 ISO 的C标准内容基本相同, 所以对于C标准, 可以称为 ANSI C, 也可以说是 ISO C, 或者 ANSI / ISO C。  
   * 看到 ANSI C, ISO C, C89, C90, 要知道这些标准的内容都是一样的
2. C99
   * 增加了新的关键字, 编写了新的库, 取消了原有的限制, 并于 1999 年形成新的标准——ISO/IEC 9899:1999 标准, 通常被成为 C99。
   * 当 GCC 和其它一些商业编译器支持 C99 的大部分特性的時候, 微软和 Borland 却似乎对此不感兴趣, 或者说没有足够的资源和动力来改进编译器, 最终导致不同的编译器在部分语法上存在差异。
3. C11
   * 国际标准化组织（ISO）和国际电工委员会（IEC） 旗下的C语言标准委员会于 2011 年底正式发布  
   * 支持此标准的主流C语言编译器有 GCC, LLVM/Clang, Intel C++ Compile 等。  


C11 标准主要增加了以下内容：
    增加了安全函数, 例如 `gets_s()`, `fopen_s()` 等；
    增加了 `<threads.h>` 头文件以支持多线程；
    增加了 `<uchar.h>` 头文件以支持 Unicode 字符集；

* 现有的教程（包括书籍, 视频, 大学课程等）大都是针对 C89 编写的, 这是C语言的核心, 后来的 C99, C11 新增的特性并不多, 只是在“打补丁”。
* 每次的更新, C 语言都会融合一些 C++的特性作为自己的内容, C和C++相互依存同时还互相学习

## 1.2. C 语言的构成

* Basic concepts
* Keywords
* Preprocessor
* Expressions
* Declaration
* Initialization
* Functions
* Statements

# Basic Concepts

# Keywords



# 2. Declaration 声明

一个 declaration 指的是把一个或者多个 标识符(identifiers) 引入到程序中, 同时指明它的 意思以及属性  

声明可以出现在任何 scope, 以 `;` 结尾

## 2.1. 声明的根本构成

声明本身是由 两个独立的部分组成 (直到 C23版本), 包括
* `specifiers-and-qualifiers`
* `declarators-and-initializers`(optional)
从 C23开始, 多了一个 `attr-spec-seq` 部分, 被称为Attribute declaration(这里暂时跳过)

### 2.1.1. specifiers-and-qualifiers 说明符和限定符

以空格为结尾的, 以下项目的`任意排序` 都是 specifiers-and-qualifiers, 包括三种说明符和一种限定符: 
* type specifiers: 类型说明符
  * void
  * arithmetic type 各种算数类型 (int 等)
  * atomic type 原子类型 (C11的新内容)
  * 由 typedef 预定义的类型名
  * struct, union, or enum specifier 
* `zero or one`  `storage-class specifiers`: 可选的 存储类型说明符
  * typedef
  * auto
  * register, static, extern, _Thread_local
  * (只有在声明函数的时候才能使用的) zero or more function specifiers:
    * inline
    * _Noreturn
* `zero or more` alignment specifiers: _Alignas 
* `zero or more` type qualifiers: 类型限定符
  * const
  * volatile
  * restrict
  * _Atomic

### 2.1.2. declarators-and-initializers 声明对象及初始化

以逗号 `,` 分割的声明对象, 一个 declaration 的 初始化 initializers 是可选的  

一个及其特殊的情况是, 如果是一个 enum, struct, and union declarations , 那么在他们用于  introduce the enumeration constants and/or tags, 是可以省略 标识符(即declarators) 部分的

一些简单的例子
```C
int a, *b=NULL; // "int" is the type specifier,
                // "a" is a declarator
                // "*b" is a declarator and NULL is its initializer
const int *f(void); // "int" is the type specifier
                    // "const" is the type qualifier
                    // "*f(void)" is the declarator
enum COLOR {RED, GREEN, BLUE} c; // "enum COLOR {RED, GREEN, BLUE}" is the type specifier
                                 // "c" is the declarator
```

declarators 和 标识符identifiers 的关系, 标识符属于一种最常见的 declarators, 完整的 declarators 种类是以下之一:
* `identifier` attr-spec-seq(optional, c23)  最常见的基本定义
* (declarators)   可以被括号括起来, 对于一些指针定义, 这是必须的
* pointer declarator :`* attr-spec-seq(optional) qualifiers(optional) declarator` 以星号修饰的 declarator
* array declarator :
  * `noptr-declarator [ static(optional) qualifiers(optional) expression ]`
  * `noptr-declarator [ qualifiers(optional) * ] `
* function declarator:  `noptr-declarator ( parameters-or-identifiers )`


## 2.2. Storage-class specifiers 存储级别 描述符

除了数据类型, 变量声明中还有另一个描述符用来指定变量或函数的两个属性:
* 存储期 (storage duration)
* 链接 (linkage)
与之相关的5个关键字如下
* auto                : automatic duration, no linkage
* register            : automatic duration, no linkage, no address
* static              : static duration, internal linkage 
* extern              : static duration, external linkage
* _Thread_local (C11)


storage duration, 即变量的生存期
* 自动存储期 (automatic storage duration)
  * 进入对象所在的块的时候自动分配存储, (注意不是声明代码执行的时候)
  * 在任何方式(goto return 结尾) 离开块时释放内存
  * VLA数组的分配和释放不遵循上面的规则, 在声明被执行的时候分配内存
* 静态存储期 (static storage duration)
  * 存储期是整个程序的执行过程
  * 在 main 函数执行前分配内存并执行初始化
* 线程存储期 C11 (thread storage duration)
  * 存储器是对象所在的线程的整个执行过程
  * 在线程启动的时候分配内存并初始化
  * 不同的线程拥有不同的对象 (跨线程访问该对象是 implementation-defined的)
* 分配存储期 (allocated storage duration)
  * 用动态内存分配的对象拥有此存储期

linkage, 指的是标识符的生效作用域, 影响存在于多个作用域的同一标识符对象
* 无连接   no linkage      
  * 标识符只存在于自己所处的当前作用域
  * 所有函数参数和 非extern 的块作用域对象 拥有此链接(可以访问该对象)
* 内部链接 internal linkage
  * 所有 static 对象拥有此链接
  * 当前翻译单元(translation unit)的所有作用域都有此链接
* 外部链接 external linkage
  * 所有非static的函数, 所有extern对象, 所有文件作用域的非static对象拥有此链接
  * 整个程序的所有翻译单元都可以访问该标识符

* 默认存储级别, 注意区分 对象, 函数, 函数参数列表
  * 在块作用域中的对象  auto
  * 在文件作用域的对象  extern
  * 所有函数           extern
    * 在块作用域的函数声明可以使用 extern 或完全不使用存储类说明符
    * 在文件作用域的函数声明可以使用 extern 或 static
  * 对结构体, 应用的存储级别递归的应用到所有成员
  * static在数组类型的函数参数中有特殊含义
  * 函数参数只能使用 register
  * 一部分标准在 C 和C++中是不同的:
    * 定义域文件作用域的 const 对象, 在不写明 extern 标识符的时候
    * 在C语言中拥有外部链接
    * 在C++中拥有内部链接
1. auto 
  * 该声明只允许存在于块作用域的对象, 除了函数参数列表
  * 指定对象为 automatic 和 no linkage
2. static
  * 静态变量, 对局部变量声明了后将存储在 全局数据区(静态数据区)
  * 使用了 static 的变量, 只能初始化一次, 以后只能改变它的值, 如果再次有初始化语句, 不报错也不生效
  * 静态变量的初始化值默认是0
  * 静态变量的优点: 具有全局变量的永久保留性, 具有局部变量的区域可见性
  * 该声明只允许存在于 文件作用域的函数, 文件和块作用域的对象, 不能用于函数参数列表
  * 指定 static 存储期和 internal linkage
3. register
  * 最快的存储类型, 存储在 CPU 中
  * 因为 寄存器变量是由 cpu 进行动态分配的
  * 只有局部变量(块作用域对象)和函数参数才能被设定成 寄存器变量
  * 寄存器变量必须和机器的字长一致, 因此只有 `int char short` 等类型才适合作为寄存器变量
  * 因为不会影响程序结果, 实际编程当中, 变量是否真的作为寄存器变量的最终决定权在编译器
    * 即使分配了 register 关键字, 因为cpu寄存器不足, 所以仍然当作 auto 变量
    * 即使没有写 register 关键字, 因为编译识别了频繁使用, 所以被分配了寄存器
    * 不管最终是否分配了寄存器, 最终都不能够进行取地址, 不能转化成指针
    * 一般 for 循环的控制增量 i 会 auto 设定成 register 变量
4. extern 
  * 可以应用于文件作用域和块作用域的对象和函数, 除了函数参数
  * 指定 static 存储期 和 external linkage
  * 对于标识符的extern再声明
    * 如果之前是 internal linkage, 则维持 
    * 如果之前是 no extern 或者不在作用域内, 则更改为 extern
5. _Thread_local (C11)
  * 最特殊的指示, 指示为线程存储期
  * 不能应用于函数声明上
  * 在对象声明时, 必须在同一对象的每次声明上都存在 _Thread_local
  * 在块作用域声明时, 必须于 static 或 extern 之一组合使用


* 外部链接的声明一般都使用在头文件中, 这样所有 include 该头文件的翻译单元都可以使用相同的标识符
* 头文件的内部链接的声明, 对于 include 该头文件的所有头文件产生一个分离且相异的对象或函数
```cpp
// header.h
void f(void); // 函数默认带外部链接
extern int state; // 声明带外部链接的对象
static const int size=5; // 使对象的链接为内部链接


// header.c 实现
static void local_f (int s){ } // 内部链接的函数定义
static int local_state; // 内部链接的对象定义
int state; // 定义外部链接的对象
void f(void){local_f(state);} // 外部链接的函数定义与实现

// main.c 应用
int x=size; // 使用只读常量
state=7; // 修改外部链接的对象的值

```

## 2.3. type qualifiers 类型限定符

* 对于任何类型, 都有对应的限定版本, 对应的变量限定符 qualifiers :
  * `const`
  * `volatile`
  * `restrict`
* 这三个限定符可以任意组合存在, 三个同时存在也没有问题
* 限定符作用于结构体的时候, 会递归的应用到所有成员

### 2.3.1. const

常量一旦被创建后其值就不能再改变, 所以常量必须在定义的同时赋值（初始化）, 后面的任何赋值行为都将引发错误。
* const 的本质, 是将修饰的对象放到只读内存中, 若程序中完全没有访问过该对象, 则该对象的存储都有可能被编译器省略
  * const 类型是可以通过 强制类型转化被赋值给非 const 的
  * 此时进行值修改的现象未定义
* const 也可以和指针变量一起使用, 这样可以限制指针变量本身, 也可以限制指针指向的数据
  * const 在*号后面的 代表指针本身为常量
  * 在* 号前面表示指针指向的对象是 const
* 为了保证 const 的完备, 编译器一般不会允许 const 向非 const 变量赋值, 但是反之可以  
* 包含了 const 成员的结构体和联合体也会称为 不可赋值左值

```c
const int MaxNum = 100; 

// const 和 type 都是用来修饰变量的, 它们的位置可以互换
// 建议将常量名的首字母大写, 以提醒程序员这是个常量
const type Name = value;

// 常量指针的三种形式
const int *p1;    // 常用这种 , 指针所指向的数据是只读的
int const *p2;    // 这两种也就是 const 和 type 可以互换的类型 , 指针所指向的数据是只读的
int * const p3;   // 指针是只读的, 也就是 p3 本身的值不能被修改；

// 还有一种指针本身和它指向的数据都有可能是只读的
const int * const p4;
int const * const p5; // 交换后的写法

struct {int a; const int b; } s1 = {.b=1}, s2 = {.b=2};
s1 = s2;  // 错误： s1 的类型无限定，但它有 const 成员


```

在C语言中, 单独定义 const 变量没有明显的优势, 完全可以使用#define命令代替。  
因此: const 通常用在函数形参中, 如果形参是一个指针, 为了防止在函数内部修改指针指向的数据, 就可以用 const 来限制。  


### 2.3.2. volatile

volatile 的作用主要体现在多线程编程中
1. 保证内存的可见性
2. 禁止指令重排序

保证内存的可见性:
* 在多线程编程中, 对于共享变量和对象, 都存储在主内存中
* 线程自己拥有工作内存, 且只能直接访问自己的工作内存
* 对于共享变量, 线程实际在执行中操作的是拷贝的副本, 而不是主内存中的原本
* 对共享变量的更新延迟导致的运算错误  即 内存的不可见性
  * 多个线程同时使用某个共享变量, 但线程中的副本的值更新不能及时的同步到主内存中
  * 内存的可见性即, 对共享变量, 对值的更新总能立即反映给所有线程, 能读取到最新值
  * 使用锁也可以实现内存的可见性, 因为对于变量的加锁和解锁总会伴随着 重新拷贝主内存和主内存写回
* volatile 修饰的作用:
  * 线程操作变量并修改的时候, 会`立即`写回主内存空间
  * 同时会引起 CPU 总线嗅探机制 告知其他线程该变量副本已经失效, 需要重新从主内存中读取
    * 总线嗅探机制即当CPU检测到对缓存(主内存)的值修改时, 会将当前缓存的行 设置无效标记
    * 是解决多级缓存的常见机制, 是CPU的机制, 不是任何语言模型的机制
    * 总线嗅探机制会持续的监听总线, 因此如果 volatile 变量过多会导致写回过于频繁, 引起总线风暴
  * volatile 可以看作非常轻量化的锁, 成本更低, 但是 volatile 不能保证变量的 `操作原子性`, 即 线程不安全
    * 毕竟 volatile 只是保证了可见性, 保证了读取到最新的值
    * 并不能保证对变量的写入更新的原子性, 如果需要原子性仍然需要锁, 或者直接使用原子类
    * 即 volatile 变量不适合线程间交流, 不提供原子性, 同步或内存顺序


禁止指令重排序
* 重排序在指令优化中很常见 (常见于各种计算机原理书籍作为重点), 特点是保证程序`单线程程序语义`的逻辑下, 优化内存的读写和流水线
* 重排序在实际的程序编译执行的过程中共有三种类型
  * 编译器优化, 改变语句的执行顺序
  * 指令级并行重排序, 现代处理器的指令并行(流水线), 为此而使用的机器指令重排序
  * 内存系统重排序, 因为CPU的读写对象是缓存, 对于数据有的可能在缓存, 有的则在内存或者需要重读, 因此实际的数据读写是乱序执行
* volatile 限定符保证了 `编译后` 的指令顺序与代码顺序一致
* 禁止指令重排序是通过 `内存屏障指令` 来实现的
  * 内存屏障 是一组`处理器指令`, 即处理器层面的解决重排序和内存可见性问题的指令
  * `LoadLoad StoreStore LoadStore StoreLoad`


### 2.3.3. restrict


## 2.4. Array declaration 数组的声明 


* 数组声明是一种特殊的声明
* 数组是由连续无空隙的内存分配的, 数组的大小在生存期间不会改变
* 声明语法
  * 1 `[ [static] [qualifiers] [expression] ] [attr-spec-seq]`
  * 2 `[ [qualifiers] [static] [expression] ] [attr-spec-seq]`
  * 1和2只是交换了 static 的位置, 完全一样的
  * 3 `[ [qualifiers] * ] [attr-spec-seq]`
  * 唯一是固定语法的就只有最外层的方括号
* 部件
  * attr-spec-seq (C23) : 最新的标准, 用于数组的属性
  * expression : 任何无逗号的表达式, 用于声明数组的大小(长度)
  * qualifiers : 只能出现在函数参数列表中, const, restrict, volatile 三种的任意组合, 因为函数参数中的数组最终其实是被转换成指针, 所以实际上是对指针进行限定
    * restrict 应用的比较多
    * 大部分情况下, 始终认为数组类型与其元素类型同等地拥有相同的限定
* 数组类型的本质
  * 数组类型不能被赋值 (除了初始化), 正是说法是数组不是可修改左值, 不能出现在赋值运算符的左侧, 尽管可以取地址. 
  * 在结构体的数组是可以被赋值的 (对结构体整个进行赋值)
  * 数组类型能够被当作是数组只有以下四种情况, 其他的情况都是被隐式转换成指向首元素的指针
    * 作为取地址运算符的操作数
    * 作为 sizeof 运算符的操作数
    * 作为用于数组初始化的字符串字面量
    * C11, 作为 _Alignof 运算符的操作数
* 分类: 在实际定义中, 数组定义可以分成几大类变体 (C99)起
  * 常量大小的数组 Arrays of constant known size
    * expression 为整数常量表达式, 且大于0 
    * 元素类型是已知常量大小的类型
    * 可以用 array initialization 来初始化值
  * 变长度数组 VLA Variable-length arrays
    * expression 不是整数常量表达式
    * 声明一个 非常量大小的数组(VLA), VLA 只能拥有动态存储期, 即不能使用 static
    * 如果编译器提供了宏 `__STDC_NO_VLA__ 1`, 说明不能使用 VLA和VM
    * VLA的声明不能出现在文件域, 即只能出现在块作用域, 同理所有的 Variably-modified types (VM) 也是一样
    * 所有的 VM , 包括 VLA , 不能拥有链接, 即不能使用 extern, 不能出现在结构体或者联合体
    * 控制流经过声明时, 对表达式求值, 然后分配数组, 数组长度在生存期内不会改变, 但是在经过相同代码的时候数组的长度可能不同
    * VLA的声明, 数组长度可以使用`*`号, 该写法只能出现在函数原型声明中 `int a[*]`, 事实上所有函数原型声明的表达式数组长度都会在编译的时候替换成*
  * 未知大小数组
    * 数组大小的表达式为空, 同时不是 出现在函数参数中的 也不是提供了初始化列表的
    * 彻底的未知, 属于一种不完整的类型. 注意`int a[*]` 仍然属于完整类型
    * 

```cpp
// Arrays of constant known size
int n[10];
int n[3]={1,2,3};
char charlist[sizeof(double)];
char str[]="abc";
int n[INT_MAX];

// Arrays of constant known size in parameter list
void fadd(double a[static 10], const double b[static 10]);
// 一样是被转换成指针
// 但是在编译的时候有条件进行编译检查, 例如保证 a,b 的数组长度至少为10
// 允许相应的优化

// 出现在方括号内部的 qualifiers 最终会应用于转换出来的指针
int g(int a[const 20]);
// a 拥有类型 int* const, 不可被更改指向的指针
void fadd(double a[static restrict 10],


// Variable-length arrays (VLA)
int a[n];
// 未知大小的数组, 只能出现在函数原型声明, 在定义的时候还是得具体的表达式
void foo(size_t x, int a[*]);
// 这种声明是不能出现在文件域的
int A[n];            // Error: file scope VLA
extern int (*p2)[n]; // Error: file scope VM


// Arrays of unknown size
extern int x[]; // x 的类型是 边界未知的 int 数组 
int a[] = {1,2,3}; // a 的类型是 3 个 int 的数组, 这种不是为止大小数组
```


# 3. Expressions C 表达式 

An expression is a sequence of `operators` and their `operands`, that specifies a computation. 

## 3.1. 一般概念

表达式具有一些基本概念, 包括 数据种类和运算符顺序  

### 3.1.1. 运算符优先级

### 3.1.2. 值类型

## 3.2. 运算符

赋值运算符 assignment:
* `= += -= *= /= %= &= |= ^= <<= >>=`

自增减运算符 in/de crement：
* `++a a++ --a a--`

数学运算符 arithmetic：
* `+ - * / % & | ^ << >>`
* 单目运算符 `~a`

比较运算符 comparison:
* `== != < > <= >=`

成员访问 member access:
* `a[b] *a &a a->b a.b`


### 3.2.1. iso646.h

一个非常小的标准库, 定义了一些运算符的宏写法

| 运算符 | 宏     |
| ------ | ------ |
| &&     | and    |
| &=     | and_eq |
| &      | bitand |
| `|`    | bitor  |
| ~      | compl  |
| !      | not    |
| !=     | not_eq |
| `||`   | or     |
| =      | or_eq  |
| ^      | xor    |
| ^=     | xor_eq |

### 3.2.2. 特殊运算符

| 特殊运算符       | 用途                 |
| ---------------- | -------------------- |
| `(...)`          | 函数调用             |
| ,                | 逗号运算符           |
| (type)           | 类型转换             |
| `?:`             | 三目运算符           |
| sizeof()         | 返回对象类型的字节数 |
| _Alignof() `C11` | 类型对其             |



## 3.3. Constants and literals 

某些字符可能作为 Constant values 可能会被定义在 C 程序中, 根据具体的表现有不同的名称
* literals  : for lvalue expressions
* constants : for non-lvalue expressions

### 3.3.1. Integer constant

允许了整数可以被直接用在表达式里
Allows values of integer type to be used in expressions directly. 

在了解 整数的语法之前, 先确定 C 语言对整数常量的定义:
* `decimal-constant`  : 十进制数字, a non-zero decimal digit (1, 2, 3, 4, 5, 6, 7, 8, 9), followed by zero or more decimal digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9) 
* `octal-constant`    : 八进制数字, the digit zero (`0`) followed by zero or more octal digits (0, 1, 2, 3, 4, 5, 6, 7) 
* `hex-constant`      : 16进制数字, the character sequence `0x` or the character sequence `0X` followed by one or more hexadecimal digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, A, b, B, c, C, d, D, e, E, f, F) 即不群分大小写
* `binary-constant`   : the character sequence `0b` or the character sequence `0B` followed by one or more binary digits (0, 1) 
* `integer-suffix`    : 附加的修正信息, 总共有两种
  * 无符号suffix `u` or `U`
  * 高精度suffix `l` or `L` or (C99新加入的) `ll` `LL` , 不能使用 `lL or Ll`
* 负数不是常量, 永远会被解释成 `-` 负号一元运算符和 正整数常量的运算结合  


一个 integer constant 是作为一个 `non-lvalue` expression 的, 其语法可以概述为:
* 以某种 `constant` 字符串为主, 后接某一个 `integer-suffix`
* 两种 integer-suffix 都是可选的, 且在出现的时候不区顺序
* (C23) 直接定义二进制数字是 C23 新增加的 `0B` `0b`
* (C23) 所有的 digits 字符之间都可以插入单个引号 `single quotes (')` 用于易读性, 会被编译器无视
* 对于16进制字符, 如果常量以`e E`结尾, 同时附加了 `+ -` 号, 为了与科学计数法的表示区别开, 需要在符号和 E 之间添加空格或者括号 


常量的 整数数据类型  The type of the integer constant : 根据数字字符的长度以及有无 suffix, 其可以赋值的数据类型是不同的
* 对于一个过于长的 integer constant, 如果编译器 compiler 支持拓展的整数类型, 例如 `__int128`, 那么常量可以被正确赋值, 否则程序会出错
* 附加了 `u U` 的整数常量只能被赋值给 `unsigned` 类型, 包括 int, long int , (C99) long long int
* 在 C99 以前, 不附加 `u U` 的话仍然可以赋值给 `unsigned long int`, 在之后这一语法被删除了
* 十进制以外的整数常量可以直接赋值给 `unsigned` 类型
* C99新加的俩种整数类型: 
  * long long int 
  * unsigned long long int
* `ll LL` 是 `l L` 的子集, 因此除非要限定数据类型的话, 使用 l 即可
  * `l L` 只能赋值给带 一个及以上 `long` 的数据类型
  * `ll LL` 只能赋值给带 `long long` 的数据类型




### 3.3.2. Floating constant

Floating constant 允许了小数可以直接被用在表达式里
Allows values of floating type to be used directly in expressions. 

# 4. C语言指针

`*` 在不同的场景下有不同的作用：
    1. 表示乘法, 例如 `int a = 3, b = 5, c;  c = a * b;` 这是最容易理解的。
    2. `*`可以用在指针变量的定义中, 表明这是一个指针变量, 以和普通变量区分开；
    3. 使用指针变量时在前面加`*`表示获取指针指向的数据, 或者说表示的是指针指向的数据本身

和指针相关的运算符优先级从高到低依次是
1. 定义中被括号( )括起来的那部分。
2. 后缀操作符：括号( )表示这是一个函数, 方括号[ ]表示这是一个数组。
3. 前缀操作符：星号`*`表示 “指向xxx的指针”。

## 4.1. 野指针

1. 指针指向的内存没有访问权限
2. 指向一块已经释放掉的内存
* 在GCC下会发生 Segment Fault 段错误

要想规避野指针, 就需要养成良好的编程习惯
1. 指针变量一定要初始化成 NULL
2. 指针内存被释放时, 一定要赋值成 NULL


## 4.2. 指针的定义
```c
// C语言的指针定义符号 * 是后结合的
//a, b, c 的类型都是 int*
int *a, *b, *c;  

// 只有 a 是指针变量, b, c 都是类型为 int 的普通变量
int *a, b, c;
```


### 4.2.1. 数组指针 数组名

* `数组名` 可以 `认为` 是一个指针, 它指向数组的第 0 个元素, 数组名和数组首地址并不总是等价
* 如果 p 是指向数组 arr 的指针, 那么也可以使用 `p[i]` 来访问数组元素, 它等价于 `arr[i]`。 
* 数组名是常量, 它的值不能改变, 而数组指针是变量（除非特别指明它是常量）, 它的值可以任意改变

```cpp
int arr[] = { 99, 15, 100, 888, 252 };

// 可以定义一个指向数组的指针
int *p = arr;
// p 指向数组中的第二个元素
int *p = &arr[2];  //也可以写作 int *p = arr + 2;


// 指针数组   二维数组指针
// [ ]的优先级高于*
int *(p1[5]);  // 指针的数组,  可以去掉括号直接写作 int *p1[5]; 一个有5个元素的数组, 元素类型是 int *
int (*p2)[5];  // 二位数组的指针, 不能去掉括号, 一个指针指向了 int[6] 类型, 通过p2+1 代表二位数组下降一行
```

数组名和指针的区别:
1. 求数组的长度, 只能使用数组名, 不能使用数组指针
2. 用操作符 sizeof 对数组名可以得到整个数组所占用的字节, 而对指针使用只会得到指针占用的字节

与普通变量名相比, 数组名既有一般性也有特殊性：
1. 一般性表现在数组名也用来指代特定的内存块, 也有类型和长度
2. 特殊性表现在数组名有时候会转换为一个指针, 而不是它所指代的数据本身的值。


### 4.2.2. 数组和指针的可交换性 下标 [] 

数组是有具体类型的, 定义一个数组 `a[6]`, 它的类型是`int [6]` 表示这是一个拥有 6 个 int 数据的集合  

C语言标准规定下列情况时,  数组类型被当作数组类型看待  
1. 当数组名作为数组定义的标识符（也就是定义或声明数组时）
2. sizeof 或 & 的操作数时

除此之外的其他的**所有**表达式中, 数组名会被转换为指向第 0 个元素的指针  
这代表以下的函数定义是完全等价的
```cpp
void func(int *parr){ ...... }
void func(int arr[]){ ...... }
void func(int arr[5]){ ...... }
// 用 sizeof(arr) 求得的是指针变量的长度, 而不是数组长度
// 要想在函数内部获得数组长度必须额外增加一个参数
```

C语言标准还规定, 数组下标`[]` 与指针的偏移量等价  
因此取下标操作符`[]`是建立在指针的基础上的一系列操作的集合:
1. 使一个指针和一个整数相加, 产生出一个新的指针
2. 然后从这个新指针（新地址）上取得数据, 即使用 `*` 运算符
对数组的引用 `a[i]` 在编译时总是被编译器改写成`*(a+i)`的形式, C语言标准也要求编译器**必须**具备这种行为。  

使用下标时, 编译器会自动把下标的步长调整到数组元素的大小:  
数组 a 中每个元素都是 int 类型, 长度为 4 个字节, 那么 `a[i+1]` 和 `a[i]` 在内存中的距离是 4（而不是 1）  


### 4.2.3. C语言字符串

C语言中没有特定的字符串类型, 我们通常是将字符串放在一个字符数组中

```cpp

char str[] = "c.biancheng.net";

// 除了字符数组, C语言还支持另外一种表示字符串的方法, 就是直接使用一个指针指向字符串
char *str = "c.biancheng.net";

// 或者
char *str;
str = "c.biancheng.net";

// 指针指向可以更改, 但是不能更改字符串数据
char *str = "Hello World!";
str = "I love C!";  //正确
str[3] = 'P';  //错误
```
两种字符串类型的区别:
1. 在内存中的存储区域不一样, 字符数组存储在全局数据区或栈区, 指针形式的字符串存储在常量区
2. 全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限
3. 常量区的字符串（也包括其他数据）只有读取权限, 没有写入权限.一旦被定义后就只能读取不能修改, 任何对它的赋值都是错误的


### 4.2.4. 函数中的指针

函数参数中的数组:
1. C语言没有从语法上支持数据集合的直接赋值
2. 在参数中书写 `int intArr[6]` 还是 `int intArr[]` 都不会创建一个数组出来, 编译器也不会为它们分配内存, 实际的数组是不存在的, 它们最终还是会转换为int *intArr这样的指针
   

函数返回值中的指针
* 函数运行结束后会销毁在它内部定义的所有局部数据, 包括局部变量, 局部数组和形式参数
* 函数返回的指针请尽量不要指向这些数据

### 4.2.5. NULL 指针

* 一个指针变量可以指向计算机中的任何一块内存, 不管该内存有没有被分配, 也不管该内存有没有使用权限, 只要把地址给它, 它就可以指向
* C语言没有一种机制来保证指向的内存的正确性, 程序员必须自己提高警惕


1. NULL 表示空指针, 是一个在 `C许多头文件中` 都定义了的宏定义, 可以在代码中直接使用
2. NUL 表示字符串的结束标志 '\0', 它是ASCII码表中的第 0 个字符。NUL 没有在C语言中定义, 仅仅是对 '\0' 的称呼, 不能在代码中直接使用


NULL 在C/C++中的定义
```cpp
// c

// 1. an integer constant expression with the value ​0​
// 2. an integer constant expression with the value 0 cast to the type void* 
// 3. A null pointer constant may be converted to any pointer type; such conversion results in the null pointer value of that type. 

// C++ compatible:
#define NULL 0

// C++ incompatible:
#define NULL (10*2 - 20)
#define NULL ((void*)0)  // 这一条是最二义性的

// -------c++-----
// (since C++11)
// 1. an integer literal with value zero
// 2. or a prvalue of type std::nullptr_t
#define NULL 0

//since C++11
#define NULL nullptr
```
### 4.2.6. void 指针

C语言的 NULL 定义为 `((void *)0)` 这也只存在于C语言

* `void` 用在函数定义中可以表示函数没有返回值或者没有形式参数
* `void *`, 表示指针指向的数据的类型是未知的。
    1. `void *` 表示一个有效指针, 它确实指向实实在在的数据, 它不是空指针的意思, 只是数据的类型尚未确定
    2. C语言动态内存分配函数 `malloc()` 的返回值就是void *类型, 因此C语言的 `malloc()` 在使用时要进行强制类型转换


### 4.2.7. 函数指针

函数指针的定义形式为:  
`returnType (*pointerName)(param list);`  
参数列表中可以同时给出参数的类型和名称, 也可以只给出参数的类型, 省略参数的名称  


第一个括号不能省略, 如果写作
`returnType *pointerName(param list);`  
就成了函数原型, 它表明函数的返回值类型为returnType *


定义`pmax` 是一个函数指针, 在前面加 * 就表示对它指向的函数进行调用。  
由于( )的优先级高于*,  `(*pmax)()` 两个括号不能省略    

# 5. 预处理命令

在编译之前对源文件进行简单加工的过程, 就称为预处理  

以`#`号开头的命令称为预处理命令  

1. 预处理 输出 `.i`
2. 编译 输出 `.o`
3. 连接 输出可执行文件

| 指令     | 说明                                                      |
| -------- | --------------------------------------------------------- |
| #        | 空指令, 无任何效果                                        |
| #include | 包含一个源代码文件                                        |
| #define  | 定义宏                                                    |
| #undef   | 取消已定义的宏                                            |
| #if      | 如果给定条件为真, 则编译下面代码                          |
| #ifdef   | 如果宏已经定义, 则编译下面代码                            |
| #ifndef  | 如果宏没有定义, 则编译下面代码                            |
| #else    | 否则                                                      |
| #elif    | 如果前面的#if给定条件不为真, 当前条件为真, 则编译下面代码 |
| #endif   | 结束一个#if……#else条件编译块                              |


## 5.1. include

`#include` 的处理过程很简单, 就是将头文件的内容插入到该命令所在的位置, 从而把头文件和当前源文件连接成一个源文件, 这与复制粘贴的效果相同。

使用尖括号< >和双引号" "的区别在于头文件的搜索路径不同：

    使用尖括号< >, 编译器会到系统路径下查找头文件；
    而使用双引号" ", 编译器首先在当前目录下查找头文件, 如果没有找到, 再到系统路径下查找。

也就是说, 使用双引号比使用尖括号多了一个查找路径, 它的功能更为强大。

## 5.2. define 宏定义

`宏定义`, 就是用一个标识符来表示一个字符串, 如果在后面的代码中出现了该标识符, 那么就全部替换成指定的字符串  (**简单粗暴的替换**)  

宏定义的一般形式为:  
`#define  宏名  字符串`  

注意点:  
1. 预处理程序对宏定义不作任何检查, 如有错误, 只能在编译已被宏展开后的源程序时发现
2. 宏定义不是说明或语句, 在行末不必加分号, 如加上分号则连分号也一起替换
3. 宏定义必须写在函数之外, 其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用`#undef`  
4. 对字符串不进行宏替换的话可以使用 双引号: `""`
5. 宏定义允许嵌套
6. 习惯上宏名用大写字母表示, 以便于与变量区别
7. 可用宏定义表示数据类型, 使书写方便 `#define UINT unsigned int`

### 5.2.1. 带参数的宏定义

`#define 宏名(形参列表) 字符串`  
* 宏名和形参列表之间不能有空格出现  
* 带参宏定义中, 不会为形式参数分配内存, 因此不必指明数据类型
* 字符串内的形参通常要用括号括起来以避免出错
  * 不仅要在参数两侧加括号, 还应该在整个字符串外加括号

```c
#define MAX(a,b) (a>b) ? a : b

// 错误
#define SQ(y) y*y 

// 错误
#define SQ(y) (y)*(y)

// 正确
#define SQ(y) ((y)*(y))
```
### 5.2.2. 特殊宏定义

在宏定义中的`#`: 用来将宏参数转换为字符串 也就是在带参数宏中的宏参数的开头和末尾添加引号  

```c
#define STR(s) #s

printf("%s", STR(c.biancheng.net));
// 等同于
printf("%s", "c.biancheng.net");

```

`##` 称为连接符, 用来将宏参数或其他的串连接起来  

```c
#define CON1(a, b) a##e##b

#define CON2(a, b) a##b##00

printf("%f\n", CON1(8.5, 2));
printf("%d\n", CON2(12, 34));

// 等同于
printf("%f\n", 8.5e2);
printf("%d\n", 123400);
```

## 5.3. 条件宏

条件编译是预处理程序的功能, 不是编译器的功能。  

### 5.3.1. if

* `#if`     命令要求判断条件为“整型常量表达式”, 也就是说, 表达式中不能包含变量, 而且结果必须是整数
* `if`      的表达式没有限制, 只要符合语法就行
```c
#if 整型常量表达式1
    程序段1

#elif 整型常量表达式2
    程序段2

#elif 整型常量表达式3
    程序段3

#else
    程序段4

#endif

```

### 5.3.2. ifdef

* #ifdef:   如果当前的宏已被定义过, 则对“程序段1”进行编译, 否则对“程序段2”进行编译。  
* #ifndef:  如果当前的宏未被定义, 则对“程序段1”进行编译, 否则对“程序段2”进行编译, 这与 #ifdef 的功能正好相反。

```cpp
#ifdef  宏名
    程序段1
#else
    程序段2
#endif
```

## 5.4. error 报错停止

`#error` 指令用于在编译期间产生错误信息 **并阻止程序的编译** , 其形式如下：  
`#error error_message`   

注意报错信息不需要加引号" "  

```c
#ifdef WIN32
#error This programme cannot compile at Windows Platform
#endif

#ifndef __cplusplus
#error 当前程序必须以C++方式编译
#endif

```
## 5.5. 预定义宏

预定义宏就是已经预先定义好的宏, 我们可以直接使用, 无需再重新定义  

| 宏名          | 功能                                            |
| ------------- | ----------------------------------------------- |
| `__LINE__`    | 表示当前源代码的行号；                          |
| `__FILE__`    | 表示当前源文件的名称；                          |
| `__DATE__`    | 表示当前的编译日期；                            |
| `__TIME__`    | 表示当前的编译时间；                            |
| `__STDC__`    | 当要求程序严格遵循ANSI C标准时该标识被赋值为1； |
| `__cplusplus` | 当编写C++程序时该标识符被定义。                 |

```c

printf("Date : %s\n", __DATE__);
// Date : Mar  6 2016
printf("Time : %s\n", __TIME__);
// Time : 11:47:15
printf("File : %s\n", __FILE__);
// File : main.c
// File : C:\Users\mozhiyan\Desktop\demo.c
printf("Line : %d\n", __LINE__);
// Line : 8

```
### 5.5.1. 平台

* Windows 有专有的宏    `_WIN32`
* Linux 有专有的宏      `__linux__`

```c
//不同的平台下引入不同的头文件
#if _WIN32  //识别windows平台
#include <windows.h>

#elif __linux__  //识别linux平台
#include <unistd.h>

#endif
```
### 5.5.2. 编译模式

VS/VC 有两种编译模式, Debug 和 Release  会定义对应的宏  
* `_DEBUG`

```c
#ifdef _DEBUG
    printf("正在使用 Debug 模式编译程序...\n");
#else
    printf("正在使用 Release 模式编译程序...\n");
#endif
```

# 6. 多文件编程

一个完整的 C++ 项目常常是由多个代码文件组成的, 根据后缀名的不同, 大致可以将它们分为如下 2 类：
* .h 文件：又称“头文件”, 用于存放常量, 函数的声明部分, 类的声明部分；
* .cpp 文件：又称“源文件”, 用于存放变量, 函数的定义部分, 类的实现部分。
注意, 引入编译器自带的头文件（包括标准头文件）用尖括号, 例如 `<iostream>`；引入自定义的头文件用 "" 双引号, 例如 `"student.h"`。 


实际上, 除了后缀不一样便于区分和管理外, 其他的几乎相同, 在 .cpp 中编写的代码同样也可以写在 .h 中。  
之所以将 .cpp 文件和 .h 文件在项目中承担的角色进行区别, 不是 C++ 语法的规定, 而是约定成俗的规范.  

1. 虽然类内部的成员函数可以在声明的同时进行定义（自动成为内联函数）, 但原则上不推荐这样使用。
   也就是说, 即便定义成员函数的代码很少, 其定义也应该放在适当的 .cpp 文件中。
2. 对于一些系统提供的库, 出于版权和保密的考虑, 大多是已经编译好的二进制文件, 其中可能仅包含 .h 文件, 而没有 .cpp 文件。

## 6.1. 从 extern 开始

1. 在实际开发中, 经常会在函数或变量定义之前就使用它们, 这个时候就需要提前声明。
2. 所谓声明（Declaration）, 就是告诉编译器我要使用这个变量或函数, 你现在没有找到它的定义不要紧, 请不要报错, 稍后我会把定义补上。

对于函数来说: 函数的定义有函数体, 函数的声明没有函数体, 编译器很容易区分定义和声明, 所以对于函数声明来说, 有没有 extern 都是一样的。  
对于变量来说: 编译器只能根据 extern 来区分, 有 extern 才是声明, 没有 extern 就是定义。  

变量的声明只有一种形式, 就是使用 extern 关键字：
```cpp
// 变量的声明
extern datatype name;
// 声明的同时初始化 但是没有实际意义
extern datatype name = value;
```
extern 是“外部”的意思, 很多教材讲到, extern 用来声明一个外部（其他文件中）的变量或函数, 也就是说, 变量或函数的定义在`其他文件`中。    
但是除了定义在外部, 定义在当前文件中也是正确的。  
因此本质上 extern 是用来声明的, 不管具体的定义是在当前文件内部还是外部, 都是正确的。  

## 6.2. 防止重复包含头文件 

1. 头文件包含命令 #include 的效果与直接复制粘贴头文件内容的效果是一样的, 预处理器实际上也是这样做的, 
   它会读取头文件的内容, 然后输出到 #include 命令所在的位置。  
2. 头文件包含是一个递归（循环）的过程, 如果被包含的头文件中还包含了其他的头文件, 预处理器会继续将它们也包含进来；
   这个过程会一直持续下去, 直到不再包含任何头文件, 这与递归的过程颇为相似。

C++ 多文件编程中, 处理多次 `#include` 导致重复引入”问题的方式有 3 种
1. 使用宏定义避免重复引入
   * #ifndef 是通过定义独一无二的宏来避免重复引入的, 这意味着每次引入头文件都要进行识别, 所以效率不高。
   * 但考虑到 C 和 C++ 都支持宏定义, 所以项目中使用 `#ifndef` 规避可能出现的“头文件重复引入”问题, 不会影响项目的可移植性。
2. 使用`#pragma once`避免重复引入
   * 一些较老版本的编译器不支持该指令
   * 但是实际中在 C/C++ , #pragma once 是一个非标准但却逐渐被很多编译器支持的指令。
3. 使用_Pragma操作符 (C99)
   * 可以看做是 `#pragma` 的增强版, 不仅可以实现 `#pragma` 所有的功能, 更重要的是, `_Pragma` 还能和宏搭配使用。
   * _Pragma 和 #pragma 有很多其他用法
4. 实际使用中
   * 强烈推荐读者选用第1种解决方案, 即采用 `#ifndef / #define / #endif`组合解决头文件被重复引入。
   * 同时考虑到编译效率和可移植性, #pragma once 和 #ifndef 经常被结合使用
   * 当编译器可以识别 #pragma once 时, 则整个文件仅被编译一次；反之, 即便编译器不识别 #pragma once 指令, 此时仍有 #ifndef 在发挥作用。


```cpp
// 宏保护的具体写法

// 这里 文件名为 xyz.h
#ifndef _XYZ_H
#define _XYZ_H
/* 具体的头文件内容 */
#endif
// 这样只要有任意一个文件包含了 `#include "xyz.h"` 则宏就会被定义, 之后的文件再包含也不会造成重复定义


// **pragma 的用法**

// 注意 #pragma once 是针对整个文件的
#pragma once
class Student {
  //......
};

// 或者
_Pragma("once")
class Student {
  //......
};

// 组合使用也可以
#pragma once
#ifndef _STUDENT_H
#define _STUDENT_H
class Student {
   //......
};
#endif
```

## 6.3. 命名空间

1. 不同头文件中也可以使用名称相同的命名空间, 但前提是位于该命名空间中的成员必须保证互不相同。
2. 当类的声明位于指定的命名空间中时, 如果要在类的外部实现其成员方法, 需同时注明**所在命名空间名和类名**  `Li::Student::display() `
3. C++ 中 `display()` 和 `display(int n)` 并不会造成重定义, 它们互为重载函数

## 6.4. const 在多文件编程中

1. 用 const 修饰的变量必须在定义的同时进行初始化操作
2. const 关键字除了表明其修饰的变量为常量外  还将所修饰变量的 `可见范围限制为当前文件`  
   因此除非 const 常量的定义和 main 主函数位于同一个 `.cpp` 文件, 否则该 const 常量只能在其所在的 `.cpp` 文件中使用

三种在多文件编程中使用其他文件中的 const 常量的方法  
第一种方式更简单, 更常用  习惯什么的都别在意  

1. 将const常量定义在.h头文件中  最常用也最简单的方法

此方式违背了“声明位于 .h 文件, 定义（实现）位于 .cpp 文件”的规律.
但是实际上还有别的习惯也是违背这个规律的 分别是 类的定义和内联函数的定义, 通常情况下它们也都定义在 .h 文件中。
```cpp
//demo.h
#ifndef _DEMO_H
#define _DEMO_H
const int num = 10;
#endif

```
2. 借助extern先声明再定义const常量

借助 extern 关键字 , 就可以遵守 “声明位于 .h 文件, 定义（实现）位于 .cpp 文件”的规律  
定义在 h 头文件中的 extern const 可以将 常量的作用范围恢复到整个文件  

```cpp
//demo.h
#ifndef _DEMO_H
#define _DEMO_H
extern const int num;  //声明 const 常量
#endif

//demo.cpp
#include "demo.h"   //一定要引入该头文件
const int num =10; // 定义
```

3. 借助extern直接定义const常量

在第2种的基础上进一步优化,直接省略掉头文件的建立, 但是这不符合编程结构习惯  
```cpp
//demo.cpp
extern const int num =10;

//main.cpp
extern const int num;
int main() {
  std::cout << num << std::endl;
  return 0;
}
```
## 6.5. 头文件应该写什么

因为声明语句是可以重复的
1. 区分普通函数和变量的声明和定义
2. 头文件中可以定义 const 对象和 static 对象
3. 头文件中可以定义内联函数 （用 inline 修饰的函数）
4. 头文件中可以定义类

```cpp
// 变量和函数的声明
extern int a;
void f();

// 定义 要区分好
int a;
void f() {}

// 成员变量是要等到具体的对象被创建时才会被定义（分配空间）
// 因此成员变量放在头文件中, 而把成员函数的实现代码放在一个 .cpp 文件中
class a{
    int a;
}
```

# 7. C语言和内存

CPU的寄存器:
* EIP (Extern Instruction Pointer) : 下一条指令的地址
* CR3 : 当前进程 `页目录` 的物理地址
* EBP : 用来指向栈底
* ESP : 用来指向栈顶

## 7.1. 操作系统基础
CPU 一个时钟内 能处理的数据大小 = 寄存器的位数 = 数据总线的宽度

### 7.1.1. 虚拟内存

* 对于程序中的全局变量, 它们的内存地址在链接时就已经被确定了, 无论程序在何时运行, 都是同样的地址
* 即 程序中看到的地址都是虚拟地址  
* 操作系统会寻找空闲的一段物理地址, 并安排虚拟地址到该段位置

虚拟地址是软件开发的 中间层的典型例子, 整个计算机发展就是不断引入新的中间层

### 7.1.2. 编译模式

现代编译器大都提供两种编译模式 : 32位 64位
* 32位下一个指针占用4字节, 即程序的理论虚拟内存大小最大为 4GB 2^32, 跟物理内存没关系
  * 如果物理内存小于程序内存, 那么会进行硬盘写入和读回操作
* 64位编译下, 一个内存占8字节, 尽管理论无限, 但由于物理内存目前没有这么大
  * (重要) 目前 Windows 和 Linux 都对虚拟地址进行了限制, 仅使用虚拟地址的低 48 位 (6字节) = 256TB

### 7.1.3. 地址对齐

* 因为内存地址都是按 字节编号, 而32位和64位CPU可以同时读取 4字节/8字节数据
* 因此CPU的实际寻址的步长为 4/8 字节
* 将数据尽量放在一个步长之内, 避免跨步长寻址, 称为 **内存对齐**
  * 在这过程中有可能会产生内存填充-浪费
* 编译器一般都会自动进行结构体内存对齐
  * 对于不同编译器有不同的实际效果区分
  * GCC 在 Debug 和 Release 模式都会全局变量进行对齐
  * VS 只有在 Release 下才会对全局变量对齐
  * 局部变量都不会对齐

```cpp
struct{
    int a;
    char b;
    int c;
}t;
sizeof(t) // 12
// 对应地址
// B69030
// B69034
// B69038

```
### 7.1.4. 内存分页

如果以程序为单位进行虚拟内存映射, 那么当物理内存不足时, 被换入换出磁盘的是整个程序, 这对于速度的影响非常大, 内存操作的粒度太大. 

现代计算机都使用 分页(Paging) 的方式对虚拟地址空间和物理空间进行分割和映射, 以减少内存操作的粒度.  
* 分页的 每个页面的大小相等, 以页为单位进行磁盘换入换出
  * 页的大小由硬件和操作系统决定
  * 目前大部分操作系统都是 4KB 大小的页
* 对于当前不用的程序数据放在磁盘中, 需要时再读入
* 物理磁盘不足时, 只需要将一部分写入磁盘即可
  * 虚拟空间的页 VP Virtual Page
  * 物理内存的页 PP Physical Page
  * 磁盘中的页   DP Disk Page
* 当程序要访问的页在硬盘而不在内存中时, 硬件可以捕获到这个消息, 发生 **页错误** page fault, 此时操作系统会接管进程, 执行对应的硬盘读入, 映射建立


页表 Page Table 是分页机制的核心:
* 通过给定页数和页内偏移, 即可确定一个物理地址
* 32位程序, 4GB的虚拟内存空间, 需要2^20个页, 即1M个元素的页表, 页表数组总大小为4M字节
  * 每个页数需要 20 位, 而一个数却占32位, 一般直接使用地址的前20位当作页数
  * 地址的后12位就是页内偏移
  * 页表数组的后12位 可以用来记录页的相关属性, 读写权限, 是否已分配物理内存, 是否已移动到磁盘等
    * 如果当前访问的内存无权访问, 则会产生异常, 并交给操作系统处理
    * 操作系统的处理一般比较粗暴, 会直接关闭程序
    * Linux 下会直接产生段错误 `Segment Fault`

多级页表 
* 4M大小的页表对于某些设备仍然过大
* 使用多级页表, 高级的成为 页目录 Page Directory
  * 地址的前10位作为 页目录下标
  * 中10位作为 页表下标
  * 后12位是页内偏移
* 只有极限情况下, 多级页表会占用 4MB+4KB 的内存, 大多数情况下, 因为程序的内存需要较小, 所以页表的个数页也较小, 内存占用少

### 7.1.5. MMU

CPU 内部的 MMU, Memory Management Unit 内存管理单元, 专门负责将虚拟地址转换成物理地址  
* 因为 MMU 在CPU内部, 因此 MMU 对内存的访问会极大影响性能
* 为了加快页表的查找, CPU 在 MMU 模块的内部加入了缓存, 专门用来存储页目录和页表  
  * 经过算法, 可以时 查页表的缓存命中率达到 90%, 剩下 10% 再去物理内存加载页表
  * 页表的构建是页目录的事, MMU 并不会对页表进行修改操作
* 在程序加载到内存并运行的时候:
  * 操作系统会维持程序页目录和页表的更新
  * 并将 页目录的 物理地址保存到CPU 的CR3 寄存器
  * 程序切换的时候, 只需要改变CR3寄存器的值即可找到对应的页表

## 7.2. C语言的内存布局

内存模型 Memory Model : 程序内存在地址空间中的分布情况
* 内存模型由操作系统构建, Linux 和 Windows 下会有所不同
* 编译模式也会影响内存模型

### 7.2.1. 内核空间

* 不管什么位系统或内存模型,  不论如何都需要有一部分给操作系统内核使用
* 这段内存地址就被成为 内核空间 Kernel Space, 高地址即偏向 FFFFFFFF 的部分
* 32位系统下, 4GB理论空间
  * Windows 默认使用高地址的 2G 空间作为内核空间
  * Linux 默认使用 高地址的 1G 空间作为内核空间
* 64位系统下
  * 高地址的 128TB 作为内核空间, 低 128TB 作为用户空间
  * 但由于当前的64位系统只使用 48位地址, 即实际的使用空间更小
    * 对于地址来说 , 还剩高位 4 个16进制数没使用
    * 此时的区分方法, 高16位二进制地址 (48-63) 必须与第 47 地址一致

![图像](http://c.biancheng.net/uploads/allimg/190122/104P51I1-0.jpg)


存在的内存分区
| 分区                   | 说明                                                   |
| ---------------------- | ------------------------------------------------------ |
| 程序代码区 code        | 存放函数体的二进制代码                                 |
| 常量区 Constant        | 存放一般的常量, 只有读取权限, 因此不会被改变值         |
| 全局数据区 Global Data | 全局变量, 静态变量等                                   |
| 堆区 Heap              | 由程序员分配和释放, 未释放的区域在程序结束时由系统回收 |
| 动态链接库             | 动态链接库的分配空间                                   |
| 栈区 Stack             | 存放函数的参数值, 局部变量等                           |

### 7.2.2. Linux 的内存模型

32 位Linux 内存的分配方法 :  (32位系统, 8位16进制字符)
* 保留区域 0x00000000~ 0x08048000
  * 低地址区域一开始的保留区域, 和高地址的内核空间不同
* 大小固定区 0x08048000 开始, 具体大小由程序决定
  * 代码区, 常量区, 全局数据区 在程序加载到内存后就分配好了, 一直存在, 所以全局变量在任何位置都能访问
  * 从低地址开始依次是
    * 程序代码区 只读
    * 常量区     只读
    * 全局数据区 读写
      * 全局变量在内存分配的时候会进行0值化操作
* 堆区 head 从大小固定区开始向上增长 ~ 
  * 堆区是程序员唯一能控制的内存区域
  * 程序员可以自由申请并分配只用
  * 堆内存在程序释放前会一直存在, 即 不会因为函数的结束而失效
  * 在函数内部产生的数据只要放到堆中, 在函数结束后在外面也能使用
* 动态链接库区 0x40000000~ 
  * 动态链接库的保存地址
* 栈区 ~0xC0000000 (注意栈区是向低地址方向增长的)
  * 函数调用时候的 参数, 局部变量, 返回地址等进行压栈
  * 执行后出栈销毁数据
* 内核区

64 位Linux 内存的分配方法 :  16位16进制字符
* 顺序相同
* 保留区域 0~ 0x400000
* 动态链接库 0x 0000 0AAA AAAA A000 
* 栈区 ~ 0x 0000 7FFF FFFF FFFF
* 内核区

### 7.2.3. Windows 的内存模型

Windows 因为是闭源的, 资料较少
* 32位下 高2GB 空间分给内核
* 64位下 高248分给内核, 8TB 分给用户程序

Windows 的内存特性:
* Windows 的地址空间被分配给了各种 exe, dll 文件, 堆, 栈
* 因为每个线程的栈都是独立的, 所以一个进程中有多少个线程, 就有多少个对应的栈
  * 每个线程默认的栈大小是 1MB
* 32位 Windows 的地址空间已经是支离破碎了, 当程序向系统申请堆空间时, 只好从这些剩下的还有没被占用的地址上分配

### 7.2.4. 进程与内存 

进程: 
* 一个可执行程序执行后即为一个进程
  * 程序是指令和数据的集合, 严格意义上来说是静态的概念
  * 进程是程序加载进内存后的活动, 是动态的概念
* 进程拥有独立的地址空间
  * `程序的内存空间` 是不严谨的说法, 因为一个进程对应一个不同的地址空间
  * 甚至会有一个程序可能会创建多个进程

### 7.2.5. 内核模式与用户模式

* 操作系统内核也是一个应用程序
  * 相比于不同的用户程序, 内核永远占有相同的内存区域, 和用户程序共享内存
  * 如果让内核处于独立的内存空间, 那么每次系统调用都会发生 进程切换, 损耗巨大
    * 寄存器更新
    * CPU数据缓存失效
    * MMU页表缓存失效
* 因为内核空间存放着操作系统的关键数据, 是所有程序共享的
  * 因此操作系统进制用户程序`直接`访问内核空间
  * 相应的, 操作系统会提供 `系统调用 API`, 称为 System Call
* 用户模式(User Mode  ): 执行用户程序自己的代码时称为用户模式
* 内核模式(Kernel Mode): 用户执行 System Call 会暂停用户程序, 转而执行内核代码, 此时称为内核模式
  * 计算机会经常进行模式切换:
  * 应用程序执行 IO, 内存申请等较为底层的操作时, 执行的都是 System Call
  * 相应的系统操作完成后, 就由内核模式转回了用户模式


从 Intel 80386 开始, 为了安全性和稳定性, CPU 设立了 ring0~3 的4个权限级别
* 目前的操作系统只利用了2个级别
* ring0 对应内核模式, 操作系统的核心, 设备驱动
* ring3, 用户程序, 操作系统的用户接口部分

## 7.3. 栈与进程 栈帧

* 栈内存由系统自动分配和释放: 
  * 发生函数调用时就为函数运行时用到的数据分配内存
  * 函数调用结束后就将之前分配的内存全部销毁
  * 所以局部变量, 参数只在当前函数中有效, 不能传递到函数外部
* 栈本质上来说是一段连续的内存
  * 现代CPU通常用寄存器来保留内存栈的地址信息
    * ebp 指向栈底 (Extend Base Pointer)
    * esp 指向栈顶 (Extend Stack Pointer)
  * 因为内存模型中, 程序栈是从高地址向低地址分配的, 所以在压栈时, esp的值会减小, 反之增大
* `Stack Overflow`
  * 对于用户程序, 栈指的是程序栈, 是每一个线程都有的自己的栈, 而不是内存模型中的栈空间
  * 栈的大小和编译器有关, 可以通过编译器指定栈内存的最大值, 一般是 8M
  * 当程序使用的栈内存大于指定值, 就会发成 stack overflow


栈帧 Stack Frame , 又称活动记录 Activate Record
* 没有栈就没有函数调用
* 发生函数调用时, 会将函数运行需要的 `全部信息` 压入栈中, 这些信息即 `栈帧`, 包括
  * 参数
  * 函数的返回地址, 即函数执行完成后, 函数调用者继续的代码地址
  * 函数调用者的状态信息, 用于恢复场景
    * ebp
  * -- 以上三种是关键信息, 会优先入栈, 然后会再分配一块较大的内存区域, 供函数体使用
  * 局部变量
  * 较大的函数返回值
  * -- 
  * 最后将其他的寄存器`ebx, esi, edi`的值压入栈

编译器相关的栈优化
* 通过寄存器来传递参数, 而不是通过栈, 这样更快
* 较小的函数返回值也可以通过寄存器来传递

栈帧的处理全流程:
1. 被调用函数的参数按调用惯例入栈
2. 返回地址入栈
3. ebp值入栈, 并将esp赋值给ebp, 当前栈顶地址编程函数栈空间的栈底
4. 继续分配预留内存空间, 用于函数执行和内部变量, (本质上就是 esp减去一定的值, 达到预留空间的目的)
5. 剩余寄存器入栈
6. -----------函数正式开始执行, 执行结束-----
7. 非重要寄存器值出栈, `ebx esi edi`
8. 检测到寄存器已出栈结束, 将 ebp赋值给esp, 当前栈底变成栈顶, 函数栈切换
9. 再次出栈, 获得调用方函数的 ebp
10. 出栈, 获得返回地址
11. 函数参数出栈


### 7.3.1. 栈与函数 调用惯例

* 程序的本质就是函数之间的相互调用, 调用方, 被调用方
* 被调用方函数的实参数是由调用方压栈的, 该行为遵守的规定成为 调用惯例(Calling Convention)
  * 调用惯例的内容:
  * 函数参数的传递方式,  栈/寄存器
  * 参数的传递顺序
  * 被调用方函数参数弹出栈方式
  * 函数名修饰方式

C语言实际上存在多种调用惯例, 但是一般不会进行指定修改  

| 调用惯例 | 参数传递方式                         | 参数出栈的操作方     | 名字修饰规则                                                     |
| -------- | ------------------------------------ | -------------------- | ---------------------------------------------------------------- |
| cdecl    | 从右到左的顺序入栈                   | 调用方               | 下划线+函数名, `max() -> _max`                                   |
| stdcall  | 从右到左的顺序入栈                   | 函数本身（被调用方） | 下划线+函数名+@+参数的字节数, `int max(int m, int n) -> _max_@8` |
| fastcall | 部分寄存器, 剩下的从右到左的顺序入栈 | 函数本身（被调用方） | @+函数名+@+参数的字节数                                          |
| pascal   | 从左到右的顺序入栈                   | 函数本身（被调用方） | 较为复杂, 这里不再展开讨论                                       |
 

* 对调用惯例的修改语法是根据编译器而不同的
  * VC/VS 写法 `int __cdecl max(int m, int n);`
  * GCC写法    `int  __attribute__((cdecl)) max(int m, int n);`


### 7.3.2. 栈溢出的本质

* 原理
  * C语言不会对数组溢出做检测
  * 栈空间中, 栈底在高位地址, 栈顶在地位地址
* Stack overflow的本质
  * 数组访问越界, 超过范围, 侵占了栈空间中 `old ebp` 的空间甚至返回地址空间
  * 函数本身可以正常执行并结束
  * 函数结束时取得错误的返回地址, 导致错误发生
* 栈溢出攻击
  * 通过精心设计栈溢出, 让返回地址指向了恶意代码

## 7.4. 堆与进程 动态内存

* 静态内存分配: 地址空间中的代码区, 常量区, 全局数据区
  * 速度快, 省去了系统申请内存的时间
  * 不灵活, 不能控制数据的作用范围
* 动态内存分配: 栈区, 堆区
  * 栈区由系统分配和管理, 不受程序员控制, 专门负责函数调用和执行
    * 一般情况下函数调用所需要的内存都在栈区分配
    * 对于较大的局部数组, 会由编译器在代码中插入对应的额外动态内存分配, 这样在对于代码执行的时候才分配内存
    * 因为栈区没有真正意义上的分配, 所以速度更快, 有 `栈内存的分配效率高于堆区` 的说法


* 堆区: 程序员控制的唯一内存区域, 随时分配和释放
  * `malloc() calloc() realloc() free()`
  * 所有内存分配都应该有对应的 free()
  * free(p) 并不会改变指针p指向的值, 为了防止访问, 应该手动将p更改为 NULL
  * sizeof() 是一个单目操作符, 用于获取类型的长度, 必须加括号

### 7.4.1. 堆与内存池

* 池化技术: 先向系统申请过量的资源, 然后自己管理, 以备不时之需
* 之所以要申请过量的资源, 是因为每次系统调用申请该资源都有较大的开销

* 动态内存的分配 - 堆的分配算法
  * 虽然系统调用可以进行内存分配, 但是频繁的系统调用的效率非常差
  * malloc() 实际上是C语言的内存管理函数, 而不是操作系统的
  * malloc() 类的函数会向操作系统 `批发` 一块较大的内存空间, 而不是函数参数指定的空间, 并由C语言对该内存空间进行管理
  * malloc() 只会给程序分配一个连续的内存空间, 而不能将多个非连续的空闲区域合并
  * 目前的 malloc() 函数已经是多种分配算法的符合, 兼顾内存分配的安全和效率


* 链表算法 - 内存块
  * 很多C语言教程都会提到 `栈内存的分配类似于数据结构中的栈, 而堆内存的分配却类似于数据结构中的链表`
  * 内存块类似于链表节点, 通过指针连接在一起
  * 内存块有一个标记位 `used`, 表示当前内存块是否已被使用
  * 分配:
    * 在需要分配内存时, 会顺序遍历整个内存块链表
    * 当发现一个内存块未被使用, 且空闲区的大小满足分配时
    * 空闲区会被进行拆分, 一部分给程序运行, 另一部分仍然空闲, 形成两个内存块
  * 释放:
    * 在执行释放内存块时, 会进行空闲区的合并
    * 此时可能会减少链表上内存块的数量
  * 实际中, 内存块大部分都是双向链表, 而非单向链表 
  * 缺点:
    * 如果内存块节点中的指针被破坏, 会导致整个堆无法工作, 而这很容易因为数组越界而发生
    * 容易形成特别小的内存碎片而不容易分配
    * 链表容易过长, 导致遍历时间增长

* 内存池 (Memory Pool) 
  * 内存池是堆分配算法的整体称呼, 表达了一种先向操作系统申请大内存, 再由编程语言自己进行管理的思想
  * 高级语言在底层都实现了自己的内存池, 也即有自己的内存管理机制, 垃圾回收
  * 除了C标准库自带的 malloc(), 还有一些第三方的实现, 比如 Goolge 的 `tcmalloc` 和 `jemalloc`
  * C/C++没有内存自动回收, 因此容易发生内存泄漏, 导致随着程序 运行内存使用越来越大, 且该问题很难调式和发现

### 7.4.2. 堆与内存泄漏 Memory Leak

* 对于由程序员分配的内存, 像是 `malloc()、calloc()、realloc()`
  * 如果没有指针指向它, 就无法进行任何操作, 会一直占用到程序结束 
  * 理解成程序和该内存失去了联系, 再也无法进行任何操作
* 内存分配一定要赋值给指针
* 所有malloc都要有对应的free

# 8. C语言多线程

关键字 : pthread.h  libpthread.a

* 线程 : 并不是一个原生概念, 于1967年才被提出, 是提高计算机资源利用率的产物
  * 最早 : 打孔机+计算机管理员, 手动切换任务
  * 中期 : 批处理操作系统, 自动完成任务切换
  * 后期 : 计算机可以充分利用程序的 IO 时间运行其他程序
* 程序运行的发展:
  * 单程序手动切换
  * 批处理自动切换
  * 多道批处理操作系统, 又称 多任务操作系统
    * 计算机内存分成多个区域, 每个区域可以存储一个程序
    * 一个程序处于IO中时, 将资源分给另一个程序
    * 进程的概念产生
  * 多进程的缺点
    * 进程切换开销巨大
    * 进程间通信难度大
    * 进程本身也会因为IO导致效率降低
* 线程 Thread
  * 一个进程至少包括一个线程
  * 同一个进程的所有线程共享进程的资源
  * 各个线程可以拥有属于自己的私有资源
  * 进程仅仅只是分配资源的单位, 不负责执行任务
* 线程共享的进程资源:
  * 代码  : 程序
  * 数据  : 全局变量, 静态变量, 堆空间的数据
  * 进程空间  : 即内存空间
  * 打开的文件  : 线程打开的文件, 可以在线程之间共享
* 相关名词:
  * 多线程程序 多线程编程 多线程进程
  * 当进程只有一个线程的时候 : 单线程进程, 主线程

多线程编程: 
* 多线程从来都不是由编程语言实现的
* 多线程涉及线程切换, 系统资源等概念, 因此多线程只能通过系统接口 API 来实现
* 学习多线程编程就是学习操作系统接口以及各个语言的API库


* C语言本身是没有多线程相关的接口的
* C++11开始封装了相关的多线程实现, 同时也匹配的在 C11 中加入了相关的线程实现 , [库的知识参考](../cppstl/thread.md)


## 8.1. Linux POSIX 标准

* 事实上所有操作系统的系统调用接口都不相同, 因此他们都遵循一个相同的标准来方便开发者使用
* POSI : Portable Operating System Interface 可以指操作系统接口, 加上X 代表 UNIX 类操作系统

* C语言的POSIX标准接口库: `pthread.h`
  * 线程相关的错误宏居然定义在别的头文件中 `errno.h`, 使用错误信息宏的时候要加入这个头文件
* 信号量锁的头文件 `semaphore.h`
* 系统的实际运行库 : `libpthread.a`


### 8.1.1. C 语言下的编译

* 既然多线程的实际运行库不是C语言自带的, 在编译的时候需要加入链接
* 多线程中, 如果主线程执行太快, 可能会导致子线程还未执行结束就被强行终止

`gcc thread.c -o thread.exe -lpthread`


### 8.1.2. 线程操作

定义于 `pthread.h` 中的基础线程操作函数:  
```c
int pthread_create(pthread_t *thread,
                   const pthread_attr_t *attr,
                   void *(*start_routine) (void *),
                   void *arg);
int pthread_join(pthread_t thread, 
                 void ** retval);

void pthread_exit(void *retval);

int pthread_cancel(pthread_t thread);
int pthread_setcancelstate( int state , int * oldstate ); 
int pthread_setcanceltype( int type , int * oldtype );

```
* `pthread_t`: 用于表示线程的数据类型, 每一个变量都代表一个线程 
* `pthread_attr_t`: 用于表示线程配置参数的结构体数据类型

* `pthread_create` 创建线程, 参数
  * `pthread_t *` : 指针变量, 也可以直接传递某个该类型变量的地址
  * `const pthread_attr_t` : 设置新线程的属性, 大部分情况下传入 NULL即可, 使用默认配置
  * `void *(*start_routine)`: 函数指针的方法传入新线程执行的函数, 该函数的参数最多有1个, 也可以不传入
    * 调用多线程执行的函数定义必须让, 形参和返回值都是 `void*` 类型
    * 如果函数需要返回值, 可以通过 `pthread_join()` 进行传递
  * `void *arg` : 传递给 start_routine 函数的实参, 不需要参数的时候传NULL即可
* 返回值
  * 0 :创建成功
  * `EAGAIN` : 系统资源不足
  * `EINVAL` : attr 参数无效
  * `EPERM` : attr 的参数非法

* `pthread_exit` 线程主动结束
  * 结束一个线程函数, 相当于 return, 但是只能用在线程函数中, 不能在普通函数中使用
  * `void* retval` 用于返回数据, 指向的数据即作为线程退出时候的返回值, 不需要的时候传入 NULL
  * retval 不能指向局部变量, 而应该指向全区或者常量, 或者栈区
  * 和return 的区别
    * pthread_exit 和 return 都用于结束函数, 且都能够达成返回值
    * 线程函数用 return 也能通过 `pthread_join` 来接收到返回值
    * pthread_exit只会结束当前线程, 不影响其他线程, 而且会有独有的 线程清理程序
      * 如果用在 main() 函数中
      * return 会直接导致主函数执行结束从而中止整个程序, 包括其他线程
      * pthread_exit 会结束主函数-主线程, 但是其他线程仍然会自然执行到结束

* `pthread_cancel` 线程被动结束
  * 一个线程向另一个线程发送终止执行的信号
  * 等同于让另一个线程立刻执行 `pthread_exit(PTHREAD_CANCELED);` 语句
  * `PTHREAD_CANCELED` 是定义在 pthread.h 的宏, 代表该线程被强制终止
  * 线程会在执行到 `cancellation points` 中止点的时候响应中止信号并中止运行, 中止点可以查阅POSIX手册得知
* 返回值:
  * 0 : 发送成功
  * `ESRCH` : 未能找到目标线程
* cancellation points 举例:
  *  pthread_join()
  *  pthread_testcancel()
  *  sleep()
  *  system()


* `pthread_join` 获取线程的返回值
  * `pthread_t` : 指定线程
  * `void **`   : 指定返回值的存储位置, 如果不需要可以设置成NULL
  * 该函数属于阻塞函数, 会一直等待到目标函数结束
  * 线程函数执行结束时, 并不会自动释放资源, 因为还有返回值
  * 该函数在捕获到线程返回时, 线程才会释放该线程所占用的资源
  * 一个线程的返回值只能被捕获一次, 如果多次调用了 pthread_join, 则只有最先调用的才能获得返回值, 其他的都会返回 `ESRCH`
* 返回值:
  * 0 : 成功捕获返回值
  * `EDEADLK` : 检测到线程发生死锁
  * `EINVAL`  : 检测到返回值获取失败: 1.目标线程禁止了其他线程获取返回值 2. 目标线程的返回值已经被别的pthread_join捕获了
  * `ESRCH` : 找不到指定的线程


* 修改线程响应 Cancel 信号的方式
* `pthread_setcancelstate` 参数
  * `int state`: 标记量, 有两个可选值
    * PTHREAD_CANCEL_ENABLE (默认值) : 当前线程会处理其它线程发送的 Cancel 信号
    * PTHREAD_CANCEL_DISABLE         : 线程不再理会其他线程发送的 Cancel 信号
  * `int * oldstate` 用于存储旧的状态值, 一般用做对线程重置的备份, 不需要则设置成 NULL
  * 执行成功返回 0
* `pthread_setcanceltype` 参数
  * `int type` : 标记量, 同样是2个值可选
    * `PTHREAD_CANCEL_DEFERRED` 默认值: 当线程执行到某个可作为取消点的函数时终止执行
    * `PTHREAD_CANCEL_ASYNCHRONOUS`: 线程接收到 Cancel 信号后立即结束执行
  * `int * oldtype` 同样是用做备份的旧值

### 8.1.3. 4种线程同步方法

* 线程同步一般指的是线程间对公共资源的访问竞争, 也就是访问限制
* Linux 提供了很多种解决方案
  1. 互斥锁     Mutex, 最简单的方案
  2. 信号量     用于处理最多N个进程可同时访问的情况
  3. 条件变量   用于搭配互斥锁
  4. 读写锁     用于处理多读少写的情况
* 除了信号量锁以外, 其他三种都是 `pthread` 中自带的
* 实现总结: 信号量是定义在别的同文件中的, 其他三个锁的函数名称较为共通
  * 名称 mutex cond rwlock
  * 定义 `pthread_*_t`
  * 宏初始化 `PTHREAD_*大写_INITIALIZER`
  * 函数初始化 `int pthread_*_init(pthread_*_t *lock, const pthread_*attr_t *attr);`
  * 手动销毁  `int pthread_*_destroy(pthread_*_t *lock);`
  * 互斥锁和读写锁的操作类似, 读写锁的加锁操作有读写区分
    *  `pthread_mutex_lock      pthread_rwlock_rdlock     pthread_rwlock_wrlock`
    *  `pthread_mutex_trylock   pthread_rwlock_tryrdlock  pthread_rwlock_trywrlock`
    *  `pthread_*_unlock`
  * 信号量用的是 post 和 wait
    * `sem_post`
    * `sem_wait`
    * `sem_trywait`
    * `sem_destroy`
  * 条件变量则是 wait 和 singal 以及 broadcast
    * `pthread_cond_wait`
    * `pthread_cond_timedwait`
    * `pthread_cond_signal`
    * `pthread_cond_broadcast`
  




1. 互斥锁 `pthread_mutex_t` : 最简单的锁
  * 互斥锁只有两个状态, unlock 和 lock
  * 互斥锁可以使用宏初始化或者函数`pthread_mutex_init`
  * 函数初始化可以自定义锁的属性, 可以对 malloc的动态内存锁进行初始化
  * 锁管理的函数可以进行阻塞, 从而达到目的
  * `pthread_mutex_lock` 是阻塞加锁
  * `pthread_mutex_trylock` 非阻塞加锁, 如果加锁失败直接返回非0返回值
  * 对于动态内存的锁, 释放内存之前需要用函数进行手动 `销毁`, 语句定义的则不需要手动
  * `pthread_mutex_destory` 用于销毁互斥锁
2. 信号量 `sem_t ` : 由 Dijkstra 提出的方法, 信号量的取值范围 >=0
  * 原子操作实现信号量的 加一 减一 操作
  * 信号量的值任何时候不能小于0
  * 线程访问资源时, 信号量减1, 访问结束 信号量加1
  * 信号量为0的时候, 访问资源的线程阻塞
  * 信号量又细分为二进制信号量和计数信号量, 二进制信号量一般作为互斥锁的代替, 功能一样
3. 条件变量 `pthread_cond_t ` : 
  * 用于处理线程的执行条件为具体的某个条件时
  * 阻塞线程, 直到接收到条件成立的信号后才继续执行
  * 条件变量锁必须和一个互斥锁搭配使用, 函数需要传入一个已经加锁的互斥锁
  * 条件阻塞函数的工作
    * 阻塞线程, 直到条件成立的信号, 将线程加入等待队列, 并解锁互斥锁
    * 当线程开始运行的时候, 解除阻塞, 互斥锁加锁
4. 读写锁 `pthread_rwlock_t `
  * 读请求可以共享, 写请求独占
  * 读和写请求同时出现时, 默认会优先分配给读请求
  
```cpp
// 互斥锁
pthread_mutex_t myMutex; 
// 初始化互斥锁, 使用宏或者函数
// 宏
pthread_mutex_t myMutex = PTHREAD_MUTEX_INITIALIZER; 

// 函数
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
pthread_mutex_init(&myMutex , NULL); 

int pthread_mutex_lock(pthread_mutex_t* mutex);   //实现加锁
int pthread_mutex_trylock(pthread_mutex_t* mutex);  //实现加锁
int pthread_mutex_unlock(pthread_mutex_t* mutex);   //实现解锁
int pthread_mutex_destroy(pthread_mutex_t *mutex);  //手动销毁互斥锁


// 信号量锁
#include <semaphore.h>
sem_t mySem;
// 信号量的初始化, pshared 0代表信号量和其他线程不共享, 1代表共享, value 设置信号量的初始值
int sem_init(sem_t *sem, int pshared, unsigned int value);

// 信号量操作
int sem_post(sem_t* sem); // 信号量加1 , 同时唤醒因该信号量阻塞的线程
int sem_wait(sem_t* sem); // 信号量减1, 阻塞函数, 会被 sem_post唤醒
int sem_trywait(sem_t* sem); // 信号量减1, 非阻塞, 信号量为0的时候立即返回 -1
int sem_destroy(sem_t* sem); // 手动销毁


// 条件变量
#include <pthread.h>
pthread_cond_t myCond;
// 同样的宏和函数两种初始化方法
pthread_cond_t myCond = PTHREAD_COND_INITIALIZER;
int pthread_cond_init(pthread_cond_t * cond, const pthread_condattr_t * attr);
// 销毁函数
int pthread_cond_destroy(pthread_cond_t *cond);


// 条件阻塞, 这里 mutex 必须传入一个已经加锁的互斥锁
// wait 可以永久阻塞线程, 直到条件成立
// timewait 可以设置等待最大值, 超出时间后, 将会返回 ETIMEDOUT 错误
int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex);
// abstime 是阻塞线程直到某个时间, 这里传入的值是绝对时间
int pthread_cond_timedwait(pthread_cond_t* cond, pthread_mutex_t* mutex, const struct timespec* abstime); 

// 条件达成信号
// 解除一个阻塞线程, 具体由线程优先级决定
int pthread_cond_signal(pthread_cond_t* cond);
// 解除等待队列中的所有被阻塞的线程
int pthread_cond_broadcast(pthread_cond_t* cond);


// 读写锁
#include <pthread.h>
pthread_rwlock_t myRWLock;

// 同样的两种初始化
pthread_rwlock_t myRWLock = PTHREAD_RWLOCK_INITIALIZER;
int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);

// 读锁请求
int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);    // 阻塞读请求
int pthread_rwlock_tryrdlock(pthread_rwlock_t* rwlock); // 非阻塞, 失败则返回非0的宏 EBUSY

// 写锁请求
int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);    // 阻塞
int pthread_rwlock_trywrlock(pthread_rwlock_t* rwlock); // 非阻塞

// 读写锁的释放使用相同的函数, 但是生效的时候, 读锁只会在所有读线程都释放完后才会真正解锁
int pthread_rwlock_unlock (pthread_rwlock_t* rwlock);

// 手动销毁
int pthread_rwlock_destroy(pthread_rwlock_t* rwlock);
```
### 8.1.4. 线程属性

* 创建线程的第二个参数 `pthread_attr_t` 为线程属性, 一般传入NULL代表默认配置

```c
#include <pthread.h>
// 函数定义
int pthread_create(pthread_t *thread,
                   const pthread_attr_t *attr,
                   void *(*start_routine) (void *),
                   void *arg);

// 属性变量结构体
typedef struct
{
  int __detachstate;
  int __schedpolicy;
  struct sched_param __schedparam;
  int __inheritsched;
  int __scope;
  size_t __guardsize;
  int __stackaddr_set;
  void* __stackaddr;
  size_t __stacksize;
} pthread_attr_t;



// 定义一个属性变量
pthread_attr_t myAttr;

// 初始化函数原型, 这是必须的
int pthread_attr_init(pthread_attr_t * attr);
// 执行初始化
pthread_attr_init(&myAttr);

// 修改线程属性的时候一般通过繁琐的函数来更改, 这些函数都是执行成功时返回0

// 获取一个配置变量的 __detachstate 值 
int pthread_attr_getdetachstate(const pthread_attr_t * attr,int * detachstate);
// 设置一个配置变量的 __detachstate 值
int pthread_attr_setdetachstate(pthread_attr_t *sttr, int detachstate);
// (特殊)直接将一个线程的 __detachstate 更改为 DETACHED
int pthread_detach(pthread_t thread);

// 获取 __schedpolicy
int pthread_attr_getschedpolicy(const pthread_attr_t *, int * policy)
// 修改 __schedpolicy
int pthread_attr_setschedpolicy(pthread_attr_*, int policy)

// 优先值相关
int pthread_attr_getschedparam(const pthread_attr_t *attr, struct sched_param *param);
int pthread_attr_setschedparam(pthread_attr_t *attr, const struct sched_param *param);
int sched_get_priority_max(int policy);   //获得最大优先级的值
int sched_get_priority_min(int policy);   //获得最小优先级的值

// 优先属性的继承规则
//获取 __inheritsched 属性的值
int pthread_attr_getinheritsched(const pthread_attr_t *attr,int *inheritsched);
//修改 __inheritsched 属性的值
int pthread_attr_setinheritsched(pthread_attr_t *attr,int inheritsched);

// scope
//获取 __scope 属性的值
int pthread_attr_getscope(const pthread_attr_t * attr,int * scope);
//修改 __scope 属性的值
int pthread_attr_setscope(pthread_attr_t * attr,int * scope);

// 栈空间大小
//获取当前栈内存的大小
int pthread_attr_getstacksize(const pthread_attr_t * attr,size_t * stacksize);
//修改栈内存的大小
int pthread_attr_setsstacksize(pthread_attr_t * attr,size_t * stacksize);

// 警戒区大小
int pthread_attr_getguardsize(const pthread_attr_t *restrict attr,size_t *restrict guardsize);
int pthread_attr_setguardsize(pthread_attr_t *attr ,size_t *guardsize);
```

线程属性的值大部分都是一个整数, 一般都是传入宏值  
* __detachstate: 占有资源的释放时机
  * `PTHREAD_CREATE_DETACHED`: 线程执行完函数后，会自行终止并释放占用的资源
  * `PTHREAD_CREATE_JOINABLE` (默认值): 线程执行完函数后不会自行释放资源, 需要等别的进程执行 pthread_join() 或者整个进程结束后释放
* __schedpolicy:  指定操作系统对该线程调度的算法
  * `SCHED_OTHER` (默认): 分时调度, 不支持设置线程优先级
  * `SCHED_FIFO` : 先到先得, 实时调度, 支持设置优先级
  * `SCHED_RR`   : 轮转法, 支持设置优先级
* __schedparam：指定线程的优先级, 默认为 0, 是否生效和 __schedpolicy 有关
  * 注意该参数`struct sched_param` 结构体, 实际上里面只有一个 `sched_priority`整形数据
  * 整数来表示线程的优先级
  * 注意: 不同的操作系统的优先级的值范围是不同的
  * 可以通过函数获得当前系统的优先值最大和最小值
* __inheritsched: 在该线程中新建的线程的属性继承规则
  * 这个属性影响的只是 __schedpolicy 和 __schedparam 两个属性
  * 默认继承父线程的属性, 可以设置成指定值
  * `PTHREAD_INHERIT_SCHED` : 默认, 继承
  * `PTHREAD_EXPLICIT_SCHED`: 非继承, 指定值
* __scope: CPU资源争夺范围
  * `PTHREAD_SCOPE_PROCESS` : 与同一进程的线程间争夺CPU
  * `PTHREAD_SCOPE_SYSTEM`  : 系统之间所有的线程之间争夺CPU
  * 注意该属性受操作系统限制, Linux 只支持 `PTHREAD_SCOPE_SYSTEM` 系统争夺
* __stacksize : 自定义线程的栈空间大小
  * 一般当线程需要较大的栈空间时, 需要手动分配
* __guardsize : 警戒缓冲区的大小
  * 警戒缓冲区是紧挨着栈空间的内存区域, 用于使栈空间超额的时候, 不会立刻引起栈溢出崩溃
  * 可以自定义缓冲区的大小




## 8.2. Windows 的POSIX

* 对于所有类 Unix 系统, 一般都支持 POSIX, 系统会自带 `pthread` 头文件和运行库
* 因为 POSIX 的影响巨大, Windows 版本的 POSIX 标准多线程的支持也被开发了出来, 库名为 `Pthreads-win32`

## 8.3. C++11 的多线程

* `pthread` 本质上是操作系统提供的接口库, C语言本体并没有多线程支持
* 在 C++11 中, 提供了新的头文件用于支持多线程编程, 相当于对系统接口的再封装
* 具体头文件包括
  * `<thread>`
  * `<mutex>`
  * `<future>`
  * `<condition_variable>`
  * `<atomic>`

具体使用方法记录在 [C++ STL thread](../cppstl/thread.md)


# 9. dlfcn.h  显示调用动态链接库

在 C/C++ 程序中显示调用动态链接库时, 无需引入和动态链接库相关的头文件  

```cpp
// 相关头文件
#include <dlfcn.h>

// 读取动态链接库 将库文件装载到内存中, 为后续使用做准备
// 使用 dlopen 函数 filename 参数用于表明目标库文件的存储位置和库名
/*
flag 参数的值有 2 种
    RTLD_NOW：将库文件中所有的资源都载入内存
    RTLD_LAZY：暂时不降库文件中的资源载入内存, 使用时才载入
*/
void *dlopen (const char *filename, int flag);


// dlsym() 函数可以获得指定函数在内存中的位置 , 如果查找失败则返回 NULL
// hanle 参数表示指向已打开库文件的指针
// symbol 参数用于指定目标函数的函数名
void *dlsym(void *handle, char *symbol);

// dlopen() 相对地, 借助 dlclose() 函数可以关闭已打开的动态链接库
// 当函数返回 0 时, 表示函数操作成功；反之, 函数执行失败
// handle 表示已打开的库文件指针
int dlclose (void *handle);


// 查错函数 dlerror() 
// 获得最近一次 dlopen(), dlsym() 或者 dlclose() 函数操作失败的错误信息
const char *dlerror(void);
```
**要点**
* filename 参数
  * 如果用户提供的是以 / 开头, 即以绝对路径表示的文件名, 则函数会前往该路径下查找库文件
  * 反之, 如果用户仅提供文件名, 则该函数会依次前往 `LD_LIBRARY_PATH` 环境变量指定的目录, `/etc/ld.so.cache` 文件中指定的目录, `/usr/lib, /usr/lib64, /lib, /lib64` 等默认搜索路径中查找。
* 目标库彻底释放
  * 调用 dlclose() 函数并不一定会将目标库彻底释放
  * 它只会是目标库的引用计数减 1, 当引用计数减为 0 时, 库文件所占用的资源才会被彻底释放


使用实例
```cpp

//打开库文件
void* handler = dlopen("libmymath.so",RTLD_LAZY);
if(dlerror() != NULL){
    printf("%s",dlerror());
}


//获取库文件中的 add() 函数
int(*add)(int,int)=dlsym(handler,"add");
if(dlerror()!=NULL){
    printf("%s",dlerror());
}

// 通过函数指针使用库函数
int sum=add(1,2);

//关闭库文件
dlclose(handler);

```